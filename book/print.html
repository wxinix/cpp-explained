<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Modern C++ Explained</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="section-lines.css">
        <link rel="stylesheet" href="version-commit.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Preface</a></li><li class="chapter-item expanded affix "><li class="part-title">Modern C++ Elements</li><li class="chapter-item expanded "><a href="primitive/index.html">Fundamental Data Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="primitive/IntTypes.html">Integer Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="primitive/IntTypes_longlong.html">Integer Type long long</a></li></ol></li><li class="chapter-item expanded "><a href="primitive/CharTypes.html">Character Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="primitive/CharTypes_CharSetsEncodings.html">Character Sets and Encodings</a></li><li class="chapter-item expanded "><a href="primitive/CharTypes_NewCharTypes.html">New Character Types</a></li><li class="chapter-item expanded "><a href="primitive/CharTypes_StringLiteralCat.html">Automatic String Literal Concatenation</a></li><li class="chapter-item expanded "><a href="primitive/CharTypes_LibrarySuppor.html">Library Support</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="namespace/index.html">Namespace</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="namespace/InlineNamespace.html">Inline Namespace</a></li><li class="chapter-item expanded "><a href="namespace/NewNestedNamespaceSyntax.html">New Nested Namespace Syntax</a></li><li class="chapter-item expanded "><a href="namespace/UnnamedNamespace.html">Unnamed Namespace</a></li><li class="chapter-item expanded "><a href="namespace/MergedNamespace.html">Merged Namespace</a></li><li class="chapter-item expanded "><a href="namespace/GlobalNamespace.html">Global Namespace</a></li></ol></li><li class="chapter-item expanded "><a href="compileval/index.html">Compile Time Evaluation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="compileval/Constexpr.html">constexpr</a></li><li class="chapter-item expanded "><a href="compileval/NumericLimit.html">std::numeric_limits</a></li><li class="chapter-item expanded "><a href="compileval/MathFunctions.html">Math functions</a></li><li class="chapter-item expanded "><a href="compileval/Lambdas.html">Lambdas</a></li><li class="chapter-item expanded "><a href="compileval/InliningConstExpr.html">Inlining constexpr</a></li><li class="chapter-item expanded "><a href="compileval/ConditionalCompilation.html">Conditional Compilation </a></li><li class="chapter-item expanded "><a href="compileval/VirtualFunctions.html">Virtual Functions</a></li><li class="chapter-item expanded "><a href="compileval/TryCatch.html">try-catch </a></li><li class="chapter-item expanded "><a href="compileval/DefaultInit.html">Initialization of constexpr Object</a></li><li class="chapter-item expanded "><a href="compileval/ConstEvalAndConstInit.html">consteval and constinit</a></li><li class="chapter-item expanded "><a href="compileval/StdIsConstant.html">std::is_constant_evaluated</a></li><li class="chapter-item expanded "><a href="compileval/OtherEnhancements.html">Other Enhancements</a></li></ol></li><li class="chapter-item expanded "><a href="typededuction/index.html">Type Deduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="typededuction/Introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="typededuction/Mechnisms.html">Mechanisms</a></li><li class="chapter-item expanded "><a href="typededuction/Rules.html">Rules</a></li><li class="chapter-item expanded "><a href="typededuction/BestPractices.html">Best Practices</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Meta-template Programming</li><li class="chapter-item expanded affix "><li class="part-title">Algorithms</li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Modern C++ Explained</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/wxinix/cpp-explained" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="preface"><a class="header" href="#preface">Preface</a></h1>
<h2 id="the-evolution-of-c-from-classical-to-modern"><a class="header" href="#the-evolution-of-c-from-classical-to-modern">The Evolution of C++: from classical to modern</a></h2>
<p>Since its inception as &quot;C with classes&quot;, C++ has experienced numerous significant revisions and improvements. The language is now standardized by ISO JTC1/SC22/WG21, a working group composed of C++ experts from various countries. The first standardized version of C++ was <code>ISO/IEC 14882:1998</code>, commonly known as <code>C++98</code>. The next edition, <code>ISO/IEC 14882:2003</code>, was a minor revision that addressed issues found in <code>C++98</code>.</p>
<p>The true revolution of C++ arrived with <code>ISO/IEC 14882:2011</code>, also known as <code>C++11</code> or <code>C++0x</code>. Officially released in 2011, it had been delayed longer than originally planned, leading developers to joke about the delay by dubbing it <code>C++0B</code>, with the hexadecimal B representing the release year. <code>C++11</code> is considered a watershed moment in the language's evolution, marking the transition from classical to modern C++. It introduced many important additions to both the core language and the standard library, including rvalue references/move semantics, auto type deduction, uniform initialization syntax using {} lists, lambdas, variadic templates, SFINAE rules, and various smart pointer classes, among other valuable features for crafting robust C++ programs.</p>
<p>A small extension to <code>C++11</code> was introduced in <code>ISO/IEC 14882:2014</code>. This was followed by another major revision <code>ISO/IEC 14882:2017</code>, which added notable features like <code>std::any</code>, <code>std::variant</code>, and <code>std::optional</code> classes to the standard library.</p>
<p><code>C++20</code>, i.e., <code>ISO/IEC 14882:2020</code> was officially published on 15 December 2020, representing the latest major revision. The most welcomed core language features of <code>C++20</code> include <code>concepts</code> for generic type constraints, <code>modules</code> for improved expression of program physical modules, and <code>coroutines</code> for non-preemptive multitasking. Among the many new standard library features, the ranges library is particularly exciting, as it enables functional programming with &quot;pipeable&quot; functions similar to <code>F#</code>, my favorite .NET language.</p>
<p>Given the impact and changes brought about by <code>C++11/14/17/20</code>, it's clear that pre-2011 C++ and post-2011 C++ are fundamentally different languages. This distinction is reflected in the terms &quot;Classical C++&quot; represented by <code>C++98</code> and &quot;Modern C++&quot; represented by <code>C++11</code> and later. Learning the reimagined modern C++ as a new language is necessary, whether it's approached with enthusiasm or apprehension.</p>
<p>C++ was designed with backward compatibility to C, allowing developers to use C-style programming constructs such as raw pointers, arrays, and null-terminated strings. As C++ has evolved, the focus has shifted towards reducing the reliance on C-style idioms and sticking to the &quot;zero overhead&quot; principle. Modern C++ is simpler, safer, more elegant, and retains its speed.</p>
<h2 id="who-this-book-is-for"><a class="header" href="#who-this-book-is-for">Who this book is for</a></h2>
<p>This book expects readers to have a basic knowledge of C++ and a genuine interest in evolving their skills in modern C++. Most chapters are beginner-friendly, while some need extra focus. Advanced meta-template programming topics may require multiple readings but can be skipped initially. Beginners should refer to other C++ books for fundamental guidance.</p>
<h2 id="what-this-book-covers"><a class="header" href="#what-this-book-covers">What this book covers</a></h2>
<p>This book focuses on helping readers understand the rationale behind new C++11 to C++20 features, discussing past C++ limitations, and examining how these features address and optimize those issues. Wherever necessary, it also explains how new features are implemented in compilers. Code samples are tested using GCC, Clang, and MSVC. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fundamental-data-types"><a class="header" href="#fundamental-data-types">Fundamental Data Types</a></h1>
<p>The fundamental types in C++ include integer types, character types, and floating-point types. These types are considered fundamental because they are built into the language itself and can be used to create more complex data structures and objects. Additionally, they are the building blocks for other C++ data types, such as arrays, structures, and classes.</p>
<p>The following table lists the type specifiers of the fundamental data types in C++.</p>
<div class="table-wrapper"><table><thead><tr><th>Character Types</th><th>Integer Types</th><th>Floating-Point Types</th></tr></thead><tbody>
<tr><td><code>char</code></td><td><code>bool</code></td><td><code>float</code></td></tr>
<tr><td><code>wchar_t</code></td><td><code>short</code></td><td><code>double</code></td></tr>
<tr><td><code>char16_t</code></td><td><code>int</code></td><td><code>long double</code></td></tr>
<tr><td><code>char32_t</code></td><td><code>long</code></td><td></td></tr>
<tr><td><code>char8_t</code></td><td><code>long long</code></td><td></td></tr>
<tr><td></td><td><code>unsigned short</code></td><td></td></tr>
<tr><td></td><td><code>unsigned int</code></td><td></td></tr>
<tr><td></td><td><code>unsigned long</code></td><td></td></tr>
<tr><td></td><td><code>unsigned long long</code></td><td></td></tr>
<tr><td></td><td><code>signed char</code></td><td></td></tr>
<tr><td></td><td><code>unsigned char</code></td><td></td></tr>
</tbody></table>
</div>
<h2 id="void"><a class="header" href="#void"><code>void</code></a></h2>
<p><code>void</code> is considered a fundamental type in C++. It represents the absence of a value and is used as a placeholder in function signatures and pointer declarations. It cannot be used to declare variables because it has no size or storage, but it is an important part of the C++ language and is often used in conjunction with other data types.</p>
<h2 id="bool"><a class="header" href="#bool"><code>bool</code></a></h2>
<p><code>bool</code> is considered an integer type in C++, but it is often treated as a separate category due to its Boolean semantics.</p>
<h2 id="signed-char-and-unsigned-char"><a class="header" href="#signed-char-and-unsigned-char"><code>signed char</code> and <code>unsigned char</code></a></h2>
<p>In C++, the <code>char</code> type is considered a distinct type that can be used to represent individual characters in text string. It is technically not considered an integer type, but does have an integer representation according to the ASCII or Unicode standard, which allows it to be used for integer calculations in some context.</p>
<p>When <code>signed</code> or <code>unsigned</code> is applied to <code>char</code>, it creates a type for small integers that can hold values between 0 and 255 (or -128 to 127 in the case of signed char).Therefore, <code>signed char</code> and <code>unsigned char</code> are both considered integer types.</p>
<p>Note that <code>char</code> is a distinct type from <code>signed char</code> and <code>unsigned char</code>, and it is not guaranteed to be signed or unsigned. The signedness of <code>char</code> is implementation-defined, and it can vary depending on the platform and the compiler.</p>
<h2 id="type-qualifiers-and-cv-correctness"><a class="header" href="#type-qualifiers-and-cv-correctness">Type qualifiers and cv-correctness</a></h2>
<p>Type specifiers can be combined with type qualifiers. In C++, there are two type qualifiers: <code>const</code> and <code>volatile</code>.</p>
<ul>
<li><code>const</code> indicates that a variable's value cannot be modified after it has been initialized.</li>
<li><code>volatile</code> indicates that a variable's value can be modified by external factors such as hardware or other processes. Sometimes, <code>volatile</code> is applied to a variable to prevent compiler optimization.</li>
</ul>
<p>CV-correctness is a programming concept in C++ that involves using the <code>const</code> and <code>volatile</code> type qualifiers to ensure that functions and data members behave correctly in the presence of <code>const</code> and <code>volatile</code> objects.</p>
<p>For example, a member function that does not modify the state of the object it operates on should be declared <code>const</code>. This ensures that the function can be called on <code>const</code> objects, and that it does not modify the state of the object.</p>
<pre><code class="language-cpp">class Example {
public:
    // Declared const because it does not modify the object state
    int getValue() const; 
private:
    int value_;
};

int Example::getValue() const {
    return value_;
}
</code></pre>
<p>A member variable can also be declared <code>const</code> if it should not be modified in any case:</p>
<pre><code class="language-cpp">class Example {
public:
    Example(int value) : value_(value) {}
    int getValue() const {
        // Cannot be modified because getValue is const
        return value_; 
    }
private:
    // Declared const to ensure it cannot be modified
    const int value_; 
};
</code></pre>
<p>The <code>volatile</code> qualifier can be applied to variables that can be changed by external factors, such as hardware or other processes. This ensures that the compiler does not optimize away accesses to the variable, which could cause incorrect behavior.</p>
<pre><code class="language-cpp">volatile int* ptr; // Pointer to a volatile int
</code></pre>
<p>Using CV-correctness can help prevent errors and improve code safety by ensuring that functions and data members behave correctly in the presence of const and volatile objects.</p>
<h2 id="mutable"><a class="header" href="#mutable"><code>mutable</code></a></h2>
<p>In C++, mutable is a type specifier that can be used to declare a non-static data member that can be modified even if the containing object is declared <code>const</code>. This is useful when the variable represents a cache or temporary value that does not affect the state of the object.</p>
<pre><code class="language-cpp">class Example {
public:
    int getValue() const {
        // Marked const, so it cannot modify any non-mutable members.
        // However, it can modify mutable members such as cachedValue_.
        if (cachedValue_ == 0) {
            cachedValue_ = someExpensiveCalculation();
        }
        return cachedValue_;
    }

private:
    // Declared mutable to allow modification even 
    // if Example object is const
    mutable int cachedValue_;
};
</code></pre>
<p>In this example, <code>cachedValue_</code> is declared as <code>mutable</code>, which allows it to be modified even if the containing object is declared <code>const</code>. The <code>getValue()</code> function is declared <code>const</code>, which means it cannot modify any non-mutable members of the Example object, but it can modify the <code>mutable</code> member <code>cachedValue_</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integer-types"><a class="header" href="#integer-types">Integer Types</a></h1>
<h2 id="common-integer-types"><a class="header" href="#common-integer-types">Common integer types</a></h2>
<p>C++ supports several integer types with varying sizes and ranges. Here is a list of the most commonly used integer types in C++, available since the earlier versions of the language. Note that <code>char</code> is treated as integer type here for practical reason, though technically it is not.</p>
<div class="table-wrapper"><table><thead><tr><th>Type name</th><th>Typical Size (in bytes)</th><th>Range</th></tr></thead><tbody>
<tr><td><code>bool</code></td><td>1</td><td>Boolean literal <code>true</code> or <code>false</code>, added in C++98</td></tr>
<tr><td><code>char</code></td><td>1</td><td>[-128, 127] or [0, 255] depending on signedness</td></tr>
<tr><td><code>short</code></td><td>2</td><td>[-32,768, 32,767]</td></tr>
<tr><td><code>int</code></td><td>4</td><td>[-2,147,483,648, 2,147,483,647]</td></tr>
<tr><td><code>long</code></td><td>4 or 8</td><td>[-2,147,483,648, 2,147,483,647] or [-9,223,372,036,854,775,808, 9,223,372,036,854,775,807] depending on platform</td></tr>
<tr><td><code>long long</code></td><td>8</td><td>[-9,223,372,036,854,775,808, 9,223,372,036,854,775,807]</td></tr>
<tr><td><code>unsigned char</code></td><td>1</td><td>[0, 255]</td></tr>
<tr><td><code>unsigned short</code></td><td>2</td><td>[0, 65,535]</td></tr>
<tr><td><code>unsigned int</code></td><td>4</td><td>[0, 4,294,967,295]</td></tr>
<tr><td><code>unsigned long</code></td><td>4 or 8</td><td>[0, 4,294,967,295] or [0, 18,446,744,073,709,551,615] depending on platform</td></tr>
<tr><td><code>unsigned long long</code></td><td>8</td><td>[0, 18,446,744,073,709,551,615]</td></tr>
</tbody></table>
</div>
<p>The C++ standard does not specify the minimum bytes for these integer types, except the following constraints:</p>
<pre><code class="language-cpp">sizeof(char)      == 1                  // Rule 1
sizeof(char)      &lt;= sizeof(short)      // Rule 2
sizeof(short)     &lt;= sizeof(int)        // Rule 3
sizeof(int)       &lt;= sizeof(long)       // Rule 4
sizeof(long)      &lt;= sizeof(long long)  // Rule 5
sizeof(char)      *  CHAR_BIT &gt;= 8      // Rule 6
sizeof(short)     *  CHAR_BIT &gt;= 16     // Rule 7
sizeof(int)       *  CHAR_BIT &gt;= 16     // Rule 8
sizeof(long)      *  CHAR_BIT &gt;= 32     // Rule 9
sizeof(long long) *  CHAR_BIT &gt;= 64     // Rule 10
</code></pre>
<p><code>CHAR_BIT</code> represents the number of bits in a char type. Although most modern architectures use 8 bits per byte, this is not always the case as some older machines may have used 7-bit bytes. Under Rule 4, C/C++ allows <code>long</code> and <code>int</code> to have the same size, but it must be at least 32 bits according to Rule 9.</p>
<h2 id="fixed-size-integer-types"><a class="header" href="#fixed-size-integer-types">Fixed size integer types</a></h2>
<p>The C++11 standard introduced new integer types such as <code>int8_t</code>, <code>int16_t</code>, <code>int32_t</code>, and <code>int64_t</code> with fixed sizes, as well as their unsigned counterparts, <code>uint8_t</code>, <code>uint16_t</code>, <code>uint32_t</code>, and <code>uint64_t</code>. These types are guaranteed to have the specified size and range on any conforming implementation. </p>
<p>The following table summarizes fixed size integer types - note that the <code>intN_t</code> and <code>uintN_t</code> types are guaranteed to have exactly <code>N</code> bits, where <code>N</code> is 8, 16, 32, or 64.</p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Size (in bytes)</th><th>Range</th></tr></thead><tbody>
<tr><td><code>int8_t</code></td><td>1</td><td>[-128, 127]</td></tr>
<tr><td><code>uint8_t</code></td><td>1</td><td>[0, 255]</td></tr>
<tr><td><code>int16_t</code></td><td>2</td><td>[-32,768, 32,767]</td></tr>
<tr><td><code>uint16_t</code></td><td>2</td><td>[0, 65,535]</td></tr>
<tr><td><code>int32_t</code></td><td>4</td><td>[-2,147,483,648, 2,147,483,647]</td></tr>
<tr><td><code>uint32_t</code></td><td>4</td><td>[0, 4,294,967,295]</td></tr>
<tr><td><code>int64_t</code></td><td>8</td><td>[-9,223,372,036,854,775,808, 9,223,372,036,854,775,807]</td></tr>
<tr><td><code>uint64_t</code></td><td>8</td><td>[0, 18,446,744,073,709,551,615]</td></tr>
</tbody></table>
</div>
<h2 id="128-bit-integer-types"><a class="header" href="#128-bit-integer-types">128-bit integer types</a></h2>
<p>The C++ standard does not define a 128-bit integer type, as of the latest version C++20.</p>
<p>However, some compilers and libraries provide extensions that define a 128-bit integer type. For example, the GCC and Clang compilers provide an __int128 type, which is a 128-bit signed integer type. The Boost Multiprecision library provides several integer types with arbitrary precision, including a boost::multiprecision::int128_t type.</p>
<div class="table-wrapper"><table><thead><tr><th>Type name</th><th>Library/Compiler</th><th>Description</th></tr></thead><tbody>
<tr><td><code>__int128</code></td><td>GCC, Clang</td><td>A 128-bit signed integer type</td></tr>
<tr><td><code>unsigned __int128</code></td><td>GCC, Clang</td><td>A 128-bit unsigned integer type</td></tr>
<tr><td><code>int128_t</code></td><td>Boost Multiprecision</td><td>A 128-bit signed integer type</td></tr>
<tr><td><code>uint128_t</code></td><td>Boost Multiprecision</td><td>A 128-bit unsigned integer type</td></tr>
</tbody></table>
</div>
<p>It's important to note that the availability and behavior of non-standard integer types may vary depending on the platform and compiler used.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integer-type-long-long"><a class="header" href="#integer-type-long-long">Integer Type long long</a></h1>
<h2 id="history"><a class="header" href="#history">History</a></h2>
<p>Before <code>long long</code> was officially added to the C++11 standard in 2011, C++ programmers already knew about the <code>long long</code>  integer type for a long time. It has been part of the C language since the C99 standard, and many major C++ compilers supported <code>long long</code> for compatibility with C.</p>
<p>As early as 1995, Roland Hartinger first proposed to add <code>long long</code>  to C++. At the time, the C committee had not yet considered this type. As a result, the C++ committee was reluctant to add a fundamental type that was not also in C. After <code>long long</code> had been added to C99, Stephen Adamczyk proposed to reconsider its addition to C++ in 2005. Finally, <code>long long</code> was accepted as part of C++ in 2011, more than ten years after it was first included in the C standard.</p>
<h2 id="bit-size"><a class="header" href="#bit-size">Bit size</a></h2>
<p>The C++ standard defines <code>long long</code> as an integer type that is at least 64 bits long, but it does not guarantee that <code>long long</code> will always be 64 bits on all platforms. The size of <code>long long</code> can depend on the architecture and the compiler being used. However, most modern platforms do support a 64-bit <code>long long</code> type. To ensure portability and avoid any potential issues, it's best to use the <code>sizeof</code> operator to determine the size of <code>long long</code> on a specific platform.</p>
<p>Remember that in C++, <code>long long</code> is a signed data type, and its corresponding unsigned data type is <code>unsigned long long</code>. It's important to note that <code>long long int</code> and <code>unsigned long long int</code> have the same meaning as <code>long long</code> and <code>unsigned long long</code>, respectively, with the latter forms being shorthand for the former ones.</p>
<h2 id="literal-suffix"><a class="header" href="#literal-suffix">Literal suffix</a></h2>
<p>The C++ standard defines <code>LL</code> and <code>ULL</code> as literal suffixes for <code>long long</code> and <code>unsigned long long</code>, respectively. When initializing a <code>long long</code> type variable, you can write it like this:</p>
<pre><code class="language-cpp">long long x = 65536LL;
</code></pre>
<p>The literal suffix <code>LL</code> can be omitted with the same result:</p>
<pre><code class="language-cpp">long long x = 65536;
</code></pre>
<p>When working with large integer values in C++, it is important to use literal suffixes to ensure that the code runs as intended. For example:</p>
<pre><code class="language-cpp">long long x = 65536 &lt;&lt; 16; // Value overflows to 0
std::cout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; std::endl;
long long y = 65536LL &lt;&lt; 16;
std::cout &lt;&lt; &quot;y = &quot; &lt;&lt; y &lt;&lt; std::endl;
</code></pre>
<p>The code <code>long long x = 65536 &lt;&lt; 16</code> performs a bitwise left shift operation on the decimal value 65536 by 16 bits, which can result in an overflow and unexpected behavior.</p>
<p>To prevent overflowing, we should use the <code>LL</code> literal suffix to ensure that the value is treated as a <code>long long</code> data type, as in <code>long long y = 65536LL &lt;&lt; 16</code>. This will ensure that the code runs as intended and the value is not unexpectedly truncated or overflowed.</p>
<h2 id="numerical-limits"><a class="header" href="#numerical-limits">Numerical limits</a></h2>
<p>We should avoid using <code>macro</code> as much as possible for defining the maximum and minimum values:</p>
<pre><code class="language-cpp">#define LLONG_MAX 9223372036854775807LL        // long long max value
#define LLONG_MIN (-9223372036854775807LL - 1) // long long min value
#define ULLONG_MAX 0xFFFFFFFFFFFFFFFFULL       // unsigned long long max value
</code></pre>
<p>Instead, we should use <code>std::numeric_limits</code>:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;limits&gt;
#include &lt;cstdio&gt;

int main(int argc, char *argv[])
{
    // Avoid these!
    std::cout &lt;&lt; &quot;LLONG_MAX = &quot;  
            &lt;&lt; LLONG_MAX  
            &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;LLONG_MIN = &quot;  
            &lt;&lt; LLONG_MIN  
            &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;ULLONG_MAX = &quot; 
            &lt;&lt; ULLONG_MAX 
            &lt;&lt; std::endl;

    std::printf(&quot;LLONG_MAX  = %lld\n&quot;, LLONG_MAX);  // format specifier %lld
    std::printf(&quot;LLONG_MIN  = %lld\n&quot;, LLONG_MIN);  // format specifier %lld
    std::printf(&quot;ULLONG_MAX = %llu\n&quot;, ULLONG_MAX); // format specifier %llu

    // Use std::numeric_limits
    std::cout &lt;&lt; &quot;std::numeric_limits&lt;long long&gt;::max() = &quot; 
            &lt;&lt; std::numeric_limits&lt;long long&gt;::max() 
            &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;std::numeric_limits&lt;long long&gt;::min() = &quot;
            &lt;&lt; std::numeric_limits&lt;long long&gt;::min()
            &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;std::numeric_limits&lt;unsigned long long&gt;::max() = &quot;
            &lt;&lt; std::numeric_limits&lt;unsigned long long&gt;::max() 
            &lt;&lt; std::endl;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="character-types"><a class="header" href="#character-types">Character Types</a></h1>
<p>In C++, <code>char</code> is not necessarily the same type as <code>signed char</code>, although on most platforms they are equivalent.</p>
<p>The C++ standard defines <code>char</code>, <code>signed char</code>, and <code>unsigned char</code> as three distinct integral types, each with its own range of representable values. The C++ standard does not specify whether <code>char</code> is <code>signed</code> or <code>unsigned</code> by default, which means that it is implementation-defined.</p>
<p>On most platforms, <code>char</code> is implemented as a signed type, and its range of representable values is the same as that of <code>signed char</code>. However, on some rare platforms, <code>char</code> may be implemented as an unsigned type, in which case it would have the same range of representable values as <code>unsigned char</code>.</p>
<p>So, while <code>char</code> and <code>signed char</code> are often the same type in C++, it is not guaranteed by the standard. To ensure portability of code that relies on the signedness of <code>char</code>, it is recommended to use <code>signed char</code> explicitly.</p>
<h2 id="issue-with-wchar_t"><a class="header" href="#issue-with-wchar_t">Issue with <code>wchar_t</code></a></h2>
<p><code>wchar_t</code> is a character type in C++ that is used to represent wide characters. It was introduced into C++ with the C++98 standard. Many Windows API functions have a wide character version that takes <code>wchar_t</code> strings as arguments. The wide character version of these functions has a suffix of <code>W</code> added to the function name. For example, the function <code>CreateFile()</code> in the Windows API has a wide character version named <code>CreateFileW()</code>. </p>
<p>The C++ standard specifies that a string literal with an <code>L</code> prefix creates a wide character string literal. </p>
<pre><code class="language-cpp">#include &lt;windows.h&gt;

int main()
{
    LPCWSTR fileName = L&quot;C:\\example\\test.txt&quot;;
    HANDLE hFile = CreateFileW(fileName, 
                               GENERIC_READ, 
                               FILE_SHARE_READ, 
                               NULL, 
                               OPEN_EXISTING, 
                               FILE_ATTRIBUTE_NORMAL, 
                               NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        // Handle error
        return 1;
    }
    // Do something with the file handle
    CloseHandle(hFile);
    return 0;
}

</code></pre>
<p>The issue with <code>wchar_t</code> is that its size is implementation-defined, which means that it can vary across different systems and compilers. The C++ standard does not specify the size of <code>wchar_t</code>, leaving it up to the implementation to decide. For example, on Windows systems, <code>wchar_t</code> is 16 bits (2 bytes), while on Unix-like systems, it is typically 32 bits (4 bytes).</p>
<p>This lack of standardization has led to portability issues when writing cross-platform code. Code that relies on <code>wchar_t</code> may not work as expected when compiled on a different system with a different <code>wchar_t</code> size. This can result in problems with data alignment, byte order, and other issues that can cause the program to behave incorrectly.</p>
<p>To address this issue, the C++11 standard introduced new character types, <code>char16_t</code> and <code>char32_t</code>, which have fixed sizes of 16 and 32 bits, respectively. These types are recommended for use in portable code, rather than <code>wchar_t</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="character-sets-and-encodings"><a class="header" href="#character-sets-and-encodings">Character Sets and Encodings</a></h1>
<h2 id="character-set"><a class="header" href="#character-set">Character set</a></h2>
<p>A character set, also known as a character repertoire, is a collection of characters and symbols that are used to represent written language in computing. Each character in a character set is assigned a unique code point, which is a numerical value that represents that character in digital form.</p>
<p>Character sets can include characters from many different writing systems and languages, such as the Latin alphabet used in English, or the Chinese characters used in Mandarin Chinese. Some character sets are designed for specific languages or scripts, while others are designed to be universal and include characters from many different languages.</p>
<p>Examples of character sets include ASCII, which includes characters commonly used in the English language, and Unicode, which is a universal character set that can represent all characters used in modern computing, including characters from many different writing systems.</p>
<h3 id="code-point"><a class="header" href="#code-point"><em>Code point</em></a></h3>
<p>A code point is a numerical value that represents a single character or symbol in a character set. Each character in a character set is assigned a unique code point, which is a specific number that identifies that character.</p>
<p>Code points are typically expressed as hexadecimal numbers, which means that they use a base-16 numbering system. For example, the code point for the letter &quot;A&quot; in the ASCII character set is 0x41, while the code point for the Greek letter &quot;α&quot; in the Unicode character set is 0x03B1.</p>
<p>Unicode comprises 1,114,112 code points in the range [0, 1,114,111]. The maximum value of Unicode code point is 1,114,111 (0x10FFFF).</p>
<h2 id="encodings"><a class="header" href="#encodings">Encodings</a></h2>
<p>Encoding involves mapping each code point to a specific sequence of bits or bytes that can be used to represent that character in digital form.</p>
<p>The Unicode standard defines a character set that includes 1,114,111 characters, each with a unique code point, and provides several encoding schemes, including UTF-8, UTF-16, and UTF-32, that allow characters to be represented using variable-length sequences of bytes.</p>
<h3 id="utf-8-encoding"><a class="header" href="#utf-8-encoding"><em>UTF-8 encoding</em></a></h3>
<p>UTF-8 is a variable-length encoding scheme. It works by mapping each Unicode code point to a sequence of 1 to 4 bytes, depending on the code point value. </p>
<div class="table-wrapper"><table><thead><tr><th>Code Point Range</th><th>Number of Bytes</th><th>Binary Format</th></tr></thead><tbody>
<tr><td>0 to 127</td><td>1 byte</td><td><code>0xxx'xxxx</code></td></tr>
<tr><td>128 to 2047</td><td>2 bytes</td><td><code>110x'xxxx, 10xx'xxxx</code></td></tr>
<tr><td>2048 to 65535</td><td>3 bytes</td><td><code>111'0xxxx 10x'xxxxx 10xx'xxxx</code></td></tr>
<tr><td>65536 to 1114111</td><td>4 bytes</td><td><code>1111'0xxx 10xx'xxxx 10xx'xxxx 10xx'xxxx</code></td></tr>
</tbody></table>
</div>
<p>Here's how UTF-8 encoding works:</p>
<ul>
<li>
<p>If the code point value is between 0 and 127 (inclusive), the code point is represented as a single byte with the same value. This means that ASCII characters (which have code point values between 0 and 127) can be represented in UTF-8 encoding using a single byte.</p>
</li>
<li>
<p>If the code point value is between 128 and 2047 (inclusive), the code point is represented as 2 bytes. The first byte starts with the binary value <code>110</code>, followed by 5 bits that represent the most significant bits of the code point value. The second byte starts with the binary value <code>10</code>, followed by 6 bits that represent the least significant bits of the code point value.</p>
</li>
<li>
<p>If the code point value is between 2048 and 65535 (inclusive), the code point is represented as 3 bytes. The first byte starts with the binary value <code>1110</code>, followed by 4 bits that represent the most significant bits of the code point value. The second and third bytes start with the binary value <code>10</code>, followed by 6 bits each that represent the remaining bits of the code point value.</p>
</li>
<li>
<p>If the code point value is between 65536 and 1114111 (inclusive), the code point is represented as 4 bytes. The first byte starts with the binary value <code>11110</code>, followed by 3 bits that represent the most significant bits of the code point value. The second, third, and fourth bytes start with the binary value <code>10</code>, followed by 6 bits each that represent the remaining bits of the code point value.</p>
</li>
</ul>
<p>By using a variable-length encoding scheme, UTF-8 encoding can represent all Unicode code points using a sequence of 1 to 4 bytes. This allows UTF-8 to be a compact and efficient encoding scheme. UTF-8 is a superset of ASCII and fully compatible with it.</p>
<p>UTF-8 has unique patterns with the first byte, and a fixed pattern with trailing bytes. This allows for easy validation of a correct UTF-8 sequence, quick &quot;scrolling&quot; to a random position and synchronizing quickly where a character will start.</p>
<h3 id="utf-16-encoding"><a class="header" href="#utf-16-encoding"><em>UTF-16 encoding</em></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Code Point Range</th><th>Number of Bytes</th><th>Binary Format</th></tr></thead><tbody>
<tr><td>0 to 65535</td><td>1 code unit (2 bytes)</td><td><code>xxxxxxxx xxxxxxxx</code></td></tr>
<tr><td>65536 to 1114111</td><td>2 code units (4 bytes)</td><td><code>110110yy yyyyyyyy 110111xx xxxxxxxx</code></td></tr>
</tbody></table>
</div>
<ul>
<li>For code points in the range of 0 to 65535, UTF-16 encoding represents each code point using a single 16-bit code unit. </li>
<li>For code points in the range of 65536 to 1114111, UTF-16 encoding represents each code point using a pair of 16-bit code units, known as a surrogate pair. The first 16-bit code unit (known as the high surrogate) has a value in the range of 0xD800 to 0xDBFF, while the second 16-bit code unit (known as the low surrogate) has a value in the range of 0xDC00 to 0xDFFF.</li>
</ul>
<h3 id="utf-32-encoding"><a class="header" href="#utf-32-encoding"><em>UTF-32 encoding</em></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Code Point Range</th><th>Number of Code Units</th><th>Binary Format</th></tr></thead><tbody>
<tr><td>0 to 1114111</td><td>1 code unit (4 bytes)</td><td><code>00000000 xxxxxxxx xxxxxxxx xxxxxxxx</code></td></tr>
</tbody></table>
</div>
<p>UTF-32 encoding represents each code point using a single 32-bit code unit, which means that every Unicode code point is represented using exactly 4 bytes of memory.</p>
<h3 id="why-not-utf-24-encoding"><a class="header" href="#why-not-utf-24-encoding"><em>Why not UTF-24 encoding</em></a></h3>
<p>Although it is theoretically possible to create a fixed-length encoding scheme using 3 bytes to represent each Unicode code point, such a scheme would not provide any significant advantages over existing ones like UTF-8, UTF-16, or UTF-32 in terms of processing or space efficiency. Many software systems and programming languages are optimized for these standard Unicode encoding schemes, making them more convenient and widely supported.</p>
<p>Furthermore, most of the commonly used Unicode code points are smaller than 65536, which means that using three bytes per code point would result in unnecessary wastage of space. Therefore, despite the theoretical possibility of a 3-byte fixed-length encoding scheme, it is not practical to use it in most real-world scenarios.</p>
<h3 id="byte-order-mark"><a class="header" href="#byte-order-mark"><em>Byte order mark</em></a></h3>
<p>The Unicode encoding of a text file can be determined by examining the byte order mark (BOM) at the beginning of the file, or by analyzing the byte sequences of the file.</p>
<div class="table-wrapper"><table><thead><tr><th>Encoding</th><th>Byte Order Mark</th></tr></thead><tbody>
<tr><td>UTF-8</td><td><code>EF BB BF</code> (optional)</td></tr>
<tr><td>UTF-16</td><td><code>FE FF</code> (big-endian) or <code>FF FE</code> (little-endian)</td></tr>
<tr><td>UTF-32</td><td><code>00 00 FE FF</code> (big-endian) or <code>FF FE 00 00</code> (little-endian)</td></tr>
</tbody></table>
</div>
<h2 id="code-page"><a class="header" href="#code-page">Code page</a></h2>
<p>The legacy term &quot;code page&quot; originated from IBM's EBCDIC-based mainframe systems. Originally, the code page numbers referred to the page numbers in the IBM standard character set manual.</p>
<p>Vendors that use a code page system allocate their own code page number to a character set and its encoding, even if it is better known by another name; for example, UTF-8 has been assigned page numbers 1208 at IBM, 65001 at Microsoft, and 4110 at SAP. </p>
<p>The following table lists Windows code pages used by Microsoft in its own Windows operating system.</p>
<div class="table-wrapper"><table><thead><tr><th>Microsoft Code Page</th><th>Code Page Number</th><th>Description</th></tr></thead><tbody>
<tr><td>Windows-1252</td><td>1252</td><td>Western European languages</td></tr>
<tr><td>Windows-1250</td><td>1250</td><td>Central and Eastern European languages</td></tr>
<tr><td>Windows-1251</td><td>1251</td><td>Cyrillic languages</td></tr>
<tr><td>Windows-1253</td><td>1253</td><td>Greek language</td></tr>
<tr><td>Windows-1254</td><td>1254</td><td>Turkish language</td></tr>
<tr><td>Windows-1255</td><td>1255</td><td>Hebrew language</td></tr>
<tr><td>Windows-1256</td><td>1256</td><td>Arabic language</td></tr>
<tr><td>Windows-1257</td><td>1257</td><td>Baltic languages</td></tr>
<tr><td>Windows-1258</td><td>1258</td><td>Vietnamese language</td></tr>
<tr><td>UTF-8</td><td>65001</td><td>8-bit Unicode</td></tr>
<tr><td>UTF-16LE</td><td>1200</td><td>16-bit Unicode, Little Endian</td></tr>
<tr><td>UTF-16BE</td><td>1201</td><td>16-bit Unicode, Big Endian</td></tr>
<tr><td>UTF-32LE</td><td>12000</td><td>32-bit Unicode, Little Endian</td></tr>
<tr><td>UTF-32BE</td><td>12001</td><td>32-bit Unicode, Big Endian</td></tr>
<tr><td>UTF-7</td><td>65000</td><td>7-bit Unicode</td></tr>
<tr><td>UTF-1</td><td>12000</td><td>8-bit Unicode</td></tr>
<tr><td>UTF-EBCDIC</td><td>1200</td><td>EBCDIC-based Unicode</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="new-character-types"><a class="header" href="#new-character-types">New Character Types</a></h1>
<h2 id="why-char-not-good-for-utf-8"><a class="header" href="#why-char-not-good-for-utf-8">Why <code>char</code> not good for UTF-8</a></h2>
<p>In C++, <code>char</code> is a fundamental type that represents a byte-sized unit of data. Historically, it has been used to represent both ASCII characters and other narrow character sets, depending on the execution environment. </p>
<p>Suppose we have the following C++ code (in C++11), with the source file saved as UTF-8 text:</p>
<pre><code class="language-cpp">// &quot;你吃饭了吗?&quot; literal is treated as a plain array of bytes, interpreted by
// the compiler as Windows-1252 single byte encoding.
const char* utf8_str = &quot;你吃饭了吗?&quot;; 
</code></pre>
<p>If the source file containing the Chinese characters &quot;你吃饭了吗?&quot; is saved as UTF-8 text, then the encoded representation of the text will also be in UTF-8 format. However, if the platform where the code is compiled is using a different encoding, such as Windows-1252, then the compiler may attempt to interpret the Chinese characters as single-byte characters in the Windows-1252 encoding, because the type of the variable <code>utf8_str</code> is declared as a plain <code>char</code> array, which relies on the execution environment to provide the encoding context. </p>
<p>For example, the Chinese character &quot;你&quot; is represented by three bytes in UTF-8, which are <code>0xE4 0xBD 0xA0</code>. When interpreted as Windows-1252, the first byte <code>0xE4</code> is an invalid character, so the compiler replaces it with the ASCII replacement character <code>0x3F</code>. As a result, every byte of the UTF-8 encoded string &quot;你吃饭了吗?&quot; is replaced with the ASCII replacement character <code>0x3F</code> before being assigned to <code>utf8_str</code>. The mismatched data can cause unexpected results and errors in the program. </p>
<h3 id="execution-environment-explained"><a class="header" href="#execution-environment-explained"><em>Execution environment explained</em></a></h3>
<p>The &quot;execution character set of the platform&quot; refers to the character encoding scheme used by the operating system and/or the compiler to represent text data internally in a computer program.</p>
<p>In C and C++, the execution character set determines how characters are represented in the char data type. The specific character set used can vary depending on the platform, compiler, and locale settings.</p>
<p>For example, on Windows systems, the default execution character set is typically based on the Windows-1252 code page, which is a superset of ASCII that includes characters for European languages. On Unix-based systems, the default execution character set is typically based on the ASCII encoding.</p>
<h2 id="utf-related-character-types"><a class="header" href="#utf-related-character-types">UTF-related character types</a></h2>
<p><code>char8_t</code> was introduced in C++20 to provide a distinct type that is guaranteed to represent an 8-bit code unit of UTF-8 encoded Unicode text. This allows for safer and more efficient handling of UTF-8 strings, as developers can use char8_t to represent individual code units of the UTF-8 encoding. This can help to avoid issues such as misinterpreting multi-byte sequences or incorrectly handling invalid code points. </p>
<p>In the following code, <code>utf8_str</code> will have the correct UTF-8 code point values, regardless of the execution character set of the platform.</p>
<pre><code class="language-cpp">// char8_t is a new C++20 type. The &quot;u8&quot; prefix makes sure the string literal is 
// interpreted as UTF-8 encoded text while enforcing type safety with char8_t.
// Without &quot;u8&quot; prefix, the string literal will be treated as &quot;const char*&quot; type,
// which is a type mismatch with char8_t, thus failing compiling.
const char8_t* utf8_str = u8&quot;你吃饭了吗?&quot;; 
// std::cout &lt;&lt; utf8_str &lt;&lt; std::endl; // This won't compile
</code></pre>
<blockquote>
<p>In C++20, there is no <code>char8_t</code>-aware I/O streams (the overloaded std::cout for <code>char8_t</code>, <code>char16_t</code> and <code>char32_t</code> are marked as &quot;delete&quot;. It is expected that the issue will be resolved in C++23 or C++26.</p>
</blockquote>
<p><code>char16_t</code> and <code>char32_t</code> were introduced in C++11 to provide support for Unicode text encoding. <code>char16_t</code> represents a 16-bit code unit of UTF-16 encoded Unicode text, while <code>char32_t</code> represents a 32-bit code unit of UTF-32 encoded Unicode text. </p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Introduced in</th><th>Main Reason for Introduction</th><th>Literal Prefix</th><th>Sample Code</th></tr></thead><tbody>
<tr><td><code>char8_t</code></td><td>C++20</td><td>UTF-8 encoding</td><td><code>u8</code></td><td><code>const char8_t* str = u8&quot;吃了吗&quot;;</code></td></tr>
<tr><td><code>char16_t</code></td><td>C++11</td><td>UTF-16 encoding</td><td><code>u</code></td><td><code>const char16_t* str = u&quot;吃了吗&quot;;</code></td></tr>
<tr><td><code>char32_t</code></td><td>C++11</td><td>UTF-32 encoding</td><td><code>U</code></td><td><code>const char32_t* str = U&quot;吃了吗&quot;;</code></td></tr>
</tbody></table>
</div>
<p>The string literal prefix <code>u8</code>, <code>u</code>, <code>U</code> were introduced in C++11. The following code won't pass compilation with C++11 because they cannot be applied to characters. It is since C++17 that these literal prefix are allowed to be used with a character.</p>
<pre><code class="language-cpp">char utf8c = u8'a'; // C++11 will fail but C++17/20 can pass
</code></pre>
<p>Also the following code would fail compiling because the value cannot fit a single byte.</p>
<pre><code class="language-cpp">char utf8c = u8'好';
</code></pre>
<h2 id="print-utf-8-string-to-console"><a class="header" href="#print-utf-8-string-to-console">Print UTF-8 string to console</a></h2>
<p><code>std::cout</code> cannot be used to output UTF-8 string to console. Use <code>printf</code> instead. On Windows, remember to set the active code page of the Windows commandline console to UTF-8 by running <code>chcp</code> command first.</p>
<pre><code class="language-bash">chcp 65001
</code></pre>
<p>The following code uses <code>printf</code> to output an UTF-8 string.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

// Remember to run Windows commandline command &quot;chcp 65001&quot; first to set the active
// code page to UTF-8.

int main() {
  // Null terminator automatically appended.
  char8_t utf8Chars[] = u8&quot;你好世界&quot;;
  // Will have two null terminators. 
  char8_t utf8CharsWithNull[] = u8&quot;你好世界\0&quot;; 

  auto len_1 = std::char_traits&lt;char8_t&gt;::length(utf8Chars);
  auto len_2 = std::char_traits&lt;char8_t&gt;::length(utf8CharsWithNull);

  cout &lt;&lt; &quot;length(utf8Chars) = &quot; 
       &lt;&lt; len_1 
       &lt;&lt; endl; // output 12

  cout &lt;&lt; &quot;length(utf8CharsWithNull) = &quot; 
       &lt;&lt; len_2 
       &lt;&lt; endl; // output 12

  cout &lt;&lt; &quot;sizeof(char8_t) = &quot; 
       &lt;&lt; sizeof(char8_t) 
       &lt;&lt; endl; // output 1
  
  // std::cout &lt;&lt; utf8Words &lt;&lt; std::endl; // This would fail compiling.  
  printf(&quot;%s&quot;, reinterpret_cast&lt;char*&gt;(&amp;utf8Chars[0]));

  /*
  for (std::size_t i = 0; i &lt; len; i++) {
    std::cout &lt;&lt; utf8Chars[i] &lt;&lt; '\n'; // This would fail compiling.
  }
  */

  return 0;
}

</code></pre>
<h2 id="print-a-character-of-utf-8-text-to-console"><a class="header" href="#print-a-character-of-utf-8-text-to-console">Print a character of UTF-8 text to console</a></h2>
<p>In C++20, the use of the <code>std::codecvt</code> facet is deprecated and discouraged. To display a UTF-8 string character on the Windows commandline console, we need to utilize the platform-specific <code>MultiByteToWideChar</code> function provided by Windows. This will convert the UTF-8 text to wide characters, which can then be output using <code>std::wcout</code>. If we need to access a particular character in the UTF-16 or UTF-32 text based on its position, we should apply the same approach.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;locale&gt;
#include &lt;string&gt;
#include &lt;Windows.h&gt;

using namespace std;

// Remember to run Windows commandline command &quot;chcp 65001&quot; first to set the active
// code page to UTF-8.

int main() {
    u8string my_string = u8&quot;こんにちは&quot;;

    // my_string[0] is the byte value of the UTF-8 text at byte position 0.
    // The actual character could have multiple bytes.
    // std::cout &lt;&lt; my_string[0] &lt;&lt; std::endl; would fail compiling.

    // Get the required buffer size  
    int len = MultiByteToWideChar(CP_UTF8,
                                  0, 
                                  reinterpret_cast&lt;const char*&gt;(my_string.data()), 
                                  static_cast&lt;int&gt;(my_string.size()), 
                                  nullptr, 
                                  0);

    // Create a buffer of the required size
    wstring my_wstring(len, 0);

    // Convert to UTF-16 
    MultiByteToWideChar(CP_UTF8, 
                        0, 
                        reinterpret_cast&lt;const char*&gt;(my_string.data()), 
                        static_cast&lt;int&gt;(my_string.size()), 
                        &amp;my_wstring[0], 
                        len); 

    locale::global(locale(&quot;en_US.UTF-8&quot;));

    // Output the string
    wcout &lt;&lt; my_wstring &lt;&lt; endl; 

    for (int i = 0; i &lt; len; i++) {
       wcout &lt;&lt; my_wstring[i] &lt;&lt; endl;    
    }

    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="automatic-string-literal-concatenation"><a class="header" href="#automatic-string-literal-concatenation">Automatic String Literal Concatenation</a></h1>
<p>Automatic concatenation of adjacent string literals is a feature present in both C and C++ programming languages. It allows the compiler to automatically merge two or more string literals that are placed next to each other, without any explicit concatenation operator. This can be useful for breaking long strings into shorter, more manageable pieces, while still treating them as a single string constant.</p>
<p>Here is an example:</p>
<pre><code class="language-cpp">const char* my_string = &quot;Hello,&quot;
                        &quot;World!&quot;;
</code></pre>
<p>The compiler will automatically concatenate the two string literals, resulting in the following:</p>
<pre><code class="language-cpp">const char* my_string = &quot;Hello,World!&quot;;
</code></pre>
<blockquote>
<p>This feature has its roots in the C programming language. It was inherited by C++ in the early 1980s.</p>
</blockquote>
<h2 id="notes-on-automatic-string-literal-concatenation"><a class="header" href="#notes-on-automatic-string-literal-concatenation">Notes on automatic string literal concatenation</a></h2>
<p>Some nuances and caveats of using automatic concatenation of adjacent string literals:</p>
<h3 id="whitespace-not-strictly-required"><a class="header" href="#whitespace-not-strictly-required"><em>Whitespace not strictly required</em></a></h3>
<p>Adjacent string literals can be separated by whitespace, like a <code>space</code>, a <code>tab</code>, or a <code>newline</code>, for the concatenation to occur. However, white space between the literals is not strictly required, so the following is still valid in both C and C++:</p>
<pre><code class="language-cpp">const char* my_string = &quot;Hello,&quot;&quot;World&quot;;
</code></pre>
<p>The compile will automatically concatenate the adjacent string literals, resulting in the following:</p>
<pre><code class="language-cpp">const char* my_string = &quot;Hello,World&quot;;

</code></pre>
<blockquote>
<p>It's a good practice to include whitespace between adjacent string literals for better readability and maintainability.</p>
</blockquote>
<h3 id="compile-time-concatenation"><a class="header" href="#compile-time-concatenation"><em>Compile time concatenation</em></a></h3>
<p>The concatenation happens at compile-time, not at runtime, which means it has no performance overhead.</p>
<h3 id="variables-or-expressions-not-allowed"><a class="header" href="#variables-or-expressions-not-allowed"><em>Variables or expressions not allowed</em></a></h3>
<p>Automatic concatenation can only be used with string literals, not with variables or other expressions.</p>
<h3 id="mixed-encodings"><a class="header" href="#mixed-encodings"><em>Mixed encodings</em></a></h3>
<p>Be aware that trying to concatenate string literals with different character encodings may lead to compilation errors or unexpected behavior. For example, the following code will result in compiler error <em>&quot;concatenation of string literals with conflicting encoding prefixes&quot;</em>.</p>
<pre><code class="language-cpp">const char8_t* utf8Chars = u8&quot;Hello,&quot; 
                           L&quot;World!&quot;;
</code></pre>
<p>If one of the string literals does not have prefix, it will be treated as having the same as others, hence the following is a valid operation:</p>
<pre><code class="language-cpp">const char8_t* utf8Chars = u8&quot;Hello,&quot; 
                           &quot;World!&quot;; // Equivalent to u8&quot;World!&quot;
</code></pre>
<h2 id="the--operator"><a class="header" href="#the--operator">The <code>+</code> operator</a></h2>
<p>Using the + operator for concatenation works differently than automatic concatenation of adjacent string literals. In C++, the <code>+</code> operator can be used to concatenate <code>std::string</code> objects or a <code>std::string</code> object and a string literal. However, the <code>+</code> operator cannot be used to concatenate two string literals directly.</p>
<p>Here is an example:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
    std::string str1 = &quot;Hello, &quot;;
    std::string str2 = &quot;World!&quot;;
    
    std::string result = str1 + str2 + &quot;Oh Yeah&quot;; // Valid in C++
    
    std::cout &lt;&lt; result &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<p>In the example above, the + operator is used to concatenate two std::string objects. However, trying to do this with string literals directly will lead to a compilation error:</p>
<pre><code class="language-cpp">const char* result = &quot;Hello, &quot; + &quot;World!&quot; + &quot;Oh Yeah; // NOT valid in C++ (or C)
</code></pre>
<p>C does not have the <code>std::string</code> class and the <code>+</code> operator for concatenation. Use functions like <code>strcat</code> or <code>strncat</code> from the <code>string.h</code> library to concatenate character arrays (null-terminated strings). Remember to allocate enough memory for the concatenated result and ensure that the destination string is null-terminated.</p>
<p>Here's an example of using strcat and strncat functions in C:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
    char str1[20] = &quot;Hello, &quot;;
    char str2[] = &quot;world!&quot;;
    char str3[20] = &quot;I am a string.&quot;;

    // Using strcat
    strcat(str1, str2);
    printf(&quot;str1 after strcat: %s\n&quot;, str1);

    // Using strncat
    strncat(str3, str2, 4);
    printf(&quot;str3 after strncat: %s\n&quot;, str3);

    return 0;
}

</code></pre>
<p>In the above code, we have used two different functions for concatenating strings.</p>
<ul>
<li>
<p><code>strcat</code> function concatenates <code>str2</code> to the end of <code>str1</code> and modifies <code>str1</code>. After the <code>strcat</code> operation, <code>str1</code> will contain the concatenated string.</p>
</li>
<li>
<p><code>strncat</code> function concatenates a specified number of characters (in this case, 4) from  <code>str2</code> to the end of <code>str3</code> and modifies <code>str3</code>. After the strncat operation, <code>str3</code> will contain the concatenated string.</p>
</li>
</ul>
<p>The output of the above code will be:</p>
<pre><code class="language-c">str1 after strcat: Hello, world!
str3 after strncat: I am a string.worl
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="library-support"><a class="header" href="#library-support">Library Support</a></h1>
<h2 id="deprecated-library-support"><a class="header" href="#deprecated-library-support">Deprecated library support</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>Purpose</th><th>Status</th></tr></thead><tbody>
<tr><td><code>template&lt;class InternT, class ExternT, class StateT&gt; class codecvt</code> defined in header <code>&lt;locale&gt;</code></td><td>Provides a template class for converting between different character encodings</td><td>Deprecated in C++20</td></tr>
<tr><td><code>&lt;codecvt&gt;</code> header</td><td>Provides a set of templates for character encoding conversion, including <code>std::codecvt_utf8</code>, <code>std::codecvt_utf16</code>, and <code>std::codecvt_utf8_utf16</code></td><td>Deprecated in C++17</td></tr>
<tr><td><code>std::wstring_convert</code></td><td>Provides a higher-level interface for converting between wide character strings (<code>std::wstring</code>) and narrow character strings (<code>std::string</code>)</td><td>Deprecated in C++17</td></tr>
</tbody></table>
</div>
<h2 id="new-string-types"><a class="header" href="#new-string-types">New string types</a></h2>
<div class="table-wrapper"><table><thead><tr><th>String Type</th><th>Description</th><th>Basic Definition</th><th>Introduced in C++</th></tr></thead><tbody>
<tr><td>u8string</td><td>A string of 8-bit characters encoded in UTF-8</td><td><code>std::basic_string&lt;char8_t&gt;</code></td><td>C++20</td></tr>
<tr><td>u16string</td><td>A string of 16-bit characters encoded in UTF-16</td><td><code>std::basic_string&lt;char16_t&gt;</code></td><td>C++11</td></tr>
<tr><td>u32string</td><td>A string of 32-bit characters encoded in UTF-32</td><td><code>std::basic_string&lt;char32_t&gt;</code></td><td>C++11</td></tr>
</tbody></table>
</div>
<h2 id="stdpmru8string"><a class="header" href="#stdpmru8string"><code>std::pmr::u8string</code></a></h2>
<p><code>std::pmr::u8string</code> is a variant of the <code>std::basic_string</code> template that represents a sequence of 8-bit characters encoded in UTF-8 format, and allows for custom memory allocation using user-defined memory resources. It is part of the C++20 <em>Polymorphic Memory Resource</em> library (<code>std::pmr</code>).</p>
<p>To use <code>std::pmr::u8string</code>, you need to include the <code>&lt;string&gt;</code> and <code>&lt;memory_resource&gt;</code> headers, and create a <code>std::pmr::memory_resource</code> object to use as the memory allocator. You can then create an instance of <code>std::pmr::u8string</code> by passing the memory allocator as a constructor argument.</p>
<p>Here's an example of how to use <code>std::pmr::u8string</code>:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;memory_resource&gt;

int main()
{
    // create a memory pool using std::pmr::monotonic_buffer_resource
    std::pmr::monotonic_buffer_resource pool(1024);

    // create an std::pmr::u8string using the memory pool
    std::pmr::u8string str(u8&quot;Hello, world!&quot;, &amp;pool);

    // print the string to the console
    printf(reinterpret_cast&lt;char*&gt;(str.data()));

    return 0;
}
</code></pre>
<h2 id="c11-way"><a class="header" href="#c11-way">C11 way</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Description</th></tr></thead><tbody>
<tr><td><code>mbrtoc16</code></td><td>Converts a multibyte sequence to a 16-bit wide character</td></tr>
<tr><td><code>c16rtomb</code></td><td>Converts a 16-bit wide character to a multibyte sequence</td></tr>
<tr><td><code>mbrtoc32</code></td><td>Converts a multibyte sequence to a 32-bit wide character</td></tr>
<tr><td><code>c32rtomb</code></td><td>Converts a 32-bit wide character to a multibyte sequence</td></tr>
</tbody></table>
</div>
<p>These are C11 functions. </p>
<blockquote>
<p>In the function name <code>mbrtoc16</code>, the &quot;rto&quot; stands for &quot;read to&quot;. This function reads a multibyte character sequence and converts it to a 16-bit wide character. The &quot;c16&quot; part of the function name indicates that the output is a 16-bit character, while the &quot;mb&quot; part indicates that the input is a multibyte character sequence.</p>
</blockquote>
<p>Here's an example of using the <code>mbrtoc16</code> function to convert a multibyte sequence to a 16-bit wide character:</p>
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;uchar.h&gt;
#include &lt;locale.h&gt;
#include &lt;wchar.h&gt;

int main() {
    setlocale(LC_ALL, &quot;en_US.UTF-8&quot;);

    char mbstr[] = &quot;Hello, world!&quot;; // Note char8_t is not part of C language yet.
    char16_t wc16;
    mbstate_t state = { 0 };
    size_t res = mbrtoc16(&amp;wc16, mbstr, sizeof(mbstr), &amp;state);
    if (res == (size_t)-1 || res == (size_t)-2) {
        printf(&quot;Error: invalid multibyte sequence\n&quot;);
        return 1;
    }
    printf(&quot;The first character is: %lc\n&quot;, (wint_t)wc16);

    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="namespace"><a class="header" href="#namespace">Namespace</a></h1>
<p>C++ namespaces provide a way to group related declarations and definitions, such as classes, functions, and variables, under a common name. This helps to avoid naming conflicts between different parts of a program or different libraries that may be used together.</p>
<p>Namespaces were introduced into the C++ standard with the release of C++98. The syntax for declaring and defining namespaces is similar to that used for classes. Here's an example:</p>
<pre><code class="language-cpp">// Declaration of a namespace
namespace MyNamespace {
    int x;
    void foo();
}

// Definition of the namespace's contents
namespace MyNamespace {
    int x = 42;
    void foo() {
        // Implementation of the function
    }
}
</code></pre>
<p>In this example, <code>MyNamespace</code> is declared and defined to contain an integer variable <code>x</code> and a function <code>foo()</code>. The namespace's contents can be accessed using the scope resolution operator <code>::</code>, like this:</p>
<pre><code class="language-cpp">int main() {
    MyNamespace::x = 10;
    MyNamespace::foo();
    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inline-namespace"><a class="header" href="#inline-namespace">Inline Namespace</a></h1>
<h2 id="what-is-inline-namespace"><a class="header" href="#what-is-inline-namespace">What is <code>inline namespace</code></a></h2>
<p>When a namespace is declared as <code>inline</code>, it means that its members are automatically injected into the enclosing parent namespace, as if they were defined directly in the parent namespace. This allows clients of the namespace to refer to its members without needing to qualify them with the namespace name.</p>
<p>For example, consider the following code:</p>
<pre><code class="language-cpp">namespace outer {
    inline namespace inner {
        void foo() {}
    }
}
</code></pre>
<p>Here, <code>inner</code> is an inline namespace that is declared within the <code>outer</code> namespace. This means that <code>foo()</code> can be accessed either as <code>outer::inner::foo()</code> or simply as <code>outer::foo()</code>.</p>
<h2 id="use-case"><a class="header" href="#use-case">Use case</a></h2>
<p>C++ <code>inline</code> namespaces were introduced in the C++11 standard to provide a mechanism for versioning and incremental updates of libraries, without breaking backward compatibility. </p>
<p>An <code>inline</code> namespace can be used to provide an updated version of a library's interface, while still allowing old code to use the previous version. By using an <code>inline</code> namespace, the new version of the library can be introduced without breaking the existing code that depends on the old version.</p>
<p>Here is an example of how an inline namespace can be used:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

/*
// Initial version of the library
namespace MyLib {
    void foo() {
        std::cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; std::endl;
    }
}
*/

// Updated version of the library, in an inline namespace
namespace MyLib {
    inline namespace v1 {
        void foo() {
            std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;
        }
    }
    
    namespace v2 {
        void foo() {
            std::cout &lt;&lt; &quot;Hello, C++11!&quot; &lt;&lt; std::endl;
        }
    }
}

// Usage of the library
int main() {
    MyLib::foo();     // calls the initial version of foo
    MyLib::v2::foo(); // calls the updated version of foo
    return 0;
}
</code></pre>
<p>This code demonstrates how backward compatibility is maintained in a library called <code>MyLib</code>, which defines two versions of a function named <code>foo()</code>. The output of the program will be:</p>
<pre><code>Hello, World!
Hello, C++11!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="new-nested-namespace-syntax"><a class="header" href="#new-nested-namespace-syntax">New Nested Namespace Syntax</a></h1>
<p>Prior to C++17, nested namespaces are defined like this:</p>
<pre><code class="language-cpp">namespace A {
    namespace B {
        namespace C {
            int foo() { return 5; }
        }
    }
}
</code></pre>
<p>With C++17, the same nested namespaces can be defined using the inline syntax concisely:</p>
<pre><code class="language-cpp">namespace A::B::C {
    int foo() { return 5; }
}
</code></pre>
<p>Both of these code snippets achieve the same result: defining a function <code>foo()</code> in the namespace <code>A::B::C</code>. The inline namespace definition syntax introduced in C++17 allows for a more compact and readable way to define nested namespaces.</p>
<h2 id="nested-inline-namespace"><a class="header" href="#nested-inline-namespace">Nested inline namespace</a></h2>
<p>The combination of the nested namespace definition syntax (introduced in C++17) and the <code>inline</code> namespace declaration is allowed in C++20.</p>
<p>The following is valid in C++20:</p>
<pre><code class="language-cpp">namespace A::B::inline C {
    int foo() { return 5; }
}
</code></pre>
<p>In this code, the <code>inline</code> keyword is applied to the <code>C</code> namespace within the nested namespace definition <code>A::B</code>. This declares <code>C</code> as an inline namespace within the enclosing namespace <code>B</code>.</p>
<p>Note <code>inline</code> keyword can appear before any namespace name except namespace <code>A</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unnamed-namespace"><a class="header" href="#unnamed-namespace">Unnamed Namespace</a></h1>
<p>The <code>unnamed namespace</code> (or anonymous namespace) is a feature in C++ that was introduced in the C++98 standard. It provides a way to declare identifiers (e.g., functions, variables, or types) with internal linkage, meaning they are only visible within the scope of their parent namespace, or translation unit (i.e., the source file) in which they are defined.</p>
<p><code>Unnamed namespaces</code> can be declared using the <code>namespace</code> keyword, followed by a pair of braces, like this:</p>
<pre><code class="language-cpp">namespace {
    // Your code here
}
</code></pre>
<p>For example, a helper function or a constant that is only needed within a single source file, can be put in an unnamed namespace to prevent it from being accessible in other parts of the program:</p>
<pre><code class="language-cpp">// File: my_file.cpp
#include &quot;my_file.h&quot;

namespace {
    const int someConstant = 42;

    void helperFunction() {
        // Implementation here
    }
}

void myPublicFunction() {
    helperFunction();
    // Other implementation details
}
</code></pre>
<p>In this example, <code>someConstant</code> and <code>helperFunction</code> are only visible within <code>my_file.cpp</code> and won't conflict with any other code using the same names.</p>
<p>Another example:</p>
<pre><code class="language-cpp">namespace my_namespace {
    namespace {
        void helperFunction() {
            // Implementation here
        }
    }

    void publicFunction() {
        helperFunction(); // This is allowed since helperFunction() is in the same parent namespace
    }
}
</code></pre>
<p>In this example, <code>helperFunction()</code> is declared within an unnamed namespace inside <code>my_namespace</code>. Although <code>helperFunction()</code> has internal linkage and is not visible outside of the translation unit, it can still be accessed by other functions within the same parent namespace (<code>my_namespace</code>), such as <code>publicFunction()</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="merged-namespace"><a class="header" href="#merged-namespace">Merged Namespace</a></h1>
<p>If a namespace is defined multiple times, its contents are merged together. For example:</p>
<pre><code class="language-cpp">// First definition of namespace MyNamespace
namespace MyNamespace {
    int x = 1;
    void foo() {
        // Implementation of the function
    }
}

// Second definition of namespace MyNamespace, with different contents
namespace MyNamespace {
    int y = 2;
    void bar() {
        // Implementation of the function
    }
}

// Usage of the namespace contents
int main() {
    MyNamespace::foo();
    MyNamespace::bar();
    std::cout &lt;&lt; MyNamespace::x + MyNamespace::y &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<p>Howerver, if the same variable is defined multiple times, a redefinition error will occur:</p>
<pre><code class="language-cpp">
#include &lt;iostream&gt;

namespace Namespace1 {
    int x = 1;
}

namespace Namespace1 {
    int x = 2;
}

int main() {
    std::cout &lt;&lt; Namespace1::x &lt;&lt; std::endl;
    std::cout &lt;&lt; Namespace2::x &lt;&lt; std::endl;
    return 0;
}


</code></pre>
<p>We'll see the following compiler error:</p>
<pre><code>&lt;source&gt;:8:9: error: redefinition of 'int Namespace1::x'
    8 |     int x = 2;
      |         ^
&lt;source&gt;:4:9: note: 'int Namespace1::x' previously defined here
    4 |     int x = 1;
      |         ^
&lt;source&gt;: In function 'int main()':
&lt;source&gt;:13:18: error: 'Namespace2' has not been declared
   13 |     std::cout &lt;&lt; Namespace2::x &lt;&lt; std::endl;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="global-namespace"><a class="header" href="#global-namespace">Global Namespace</a></h1>
<p>In C++, the global namespace is the outermost namespace that encompasses all the code in a program. When you define a variable, function, or type without explicitly placing it in a named or unnamed namespace, it becomes part of the global namespace. The global namespace is accessible from anywhere in the program, making its members visible across different translation units.</p>
<p>Although using the global namespace can make it easier to access identifiers without needing to specify a particular namespace, it is generally not recommended to place many identifiers in the global namespace, as it can lead to name clashes and reduced code maintainability. In large projects, putting too many identifiers in the global namespace can make it difficult to determine the purpose or origin of a particular identifier.</p>
<p>Instead, it's usually better to use named namespaces to organize and encapsulate your code, which helps prevent name collisions and improve code readability.</p>
<p>Here's an example that demonstrates the difference between global and named namespaces:</p>
<pre><code class="language-cpp">// Global namespace
int globalVariable = 10;

void globalFunction() {
    // Implementation here
}

// Named namespace
namespace my_namespace {
    int myVariable = 20;

    void myFunction() {
        // Implementation here
    }
}

int main() {
    globalFunction(); // Accessing a function in the global namespace
    my_namespace::myFunction(); // Accessing a function in a named namespace

    return 0;
}
</code></pre>
<p>In this example, <code>globalVariable</code> and <code>globalFunction()</code> are defined in the global namespace, while <code>myVariable</code> and <code>myFunction()</code> are defined within the named namespace <code>my_namespace</code>. To access members of a named namespace, use the namespace qualifier <code>::</code>.</p>
<h2 id="scope-resolution-operator-"><a class="header" href="#scope-resolution-operator-">Scope resolution operator <code>::</code></a></h2>
<p>The global namespace can be accessed explicitly by using the scope resolution operator <code>::</code>. This can be helpful when an identifier in the global namespace shares the same name as an identifier in a different namespace, or it is desirable to explicitly refer to the global namespace version of an identifier.</p>
<p>Here's an example demonstrating the use of <code>::</code> to access the global namespace:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

// Global namespace
int myVariable = 10;

namespace my_namespace {
    int myVariable = 20;

    void printVariables() {
        std::cout &lt;&lt; &quot;Global namespace myVariable: &quot; &lt;&lt; ::myVariable &lt;&lt; std::endl;
        std::cout &lt;&lt; &quot;my_namespace myVariable: &quot; &lt;&lt; myVariable &lt;&lt; std::endl;
    }
}

int main() {
    my_namespace::printVariables();
    return 0;
}
</code></pre>
<p>In this example, there are two variables with the same name <code>myVariable</code>, one in the global namespace and another in the named namespace <code>my_namespace</code>. Inside the <code>printVariables()</code> function, resolution operator <code>::</code> is specified to access the <code>myVariable</code> from the global namespace, while the unqualified <code>myVariable</code> refers to the one in the <code>my_namespace</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compile-time-evaluation"><a class="header" href="#compile-time-evaluation">Compile Time Evaluation</a></h1>
<p>In C++, compile-time evaluation refers to the ability to evaluate expressions and perform computations at compile-time, rather than at runtime. This can be achieved using keywords such as <code>constexpr</code>, <code>consteval</code>, and <code>constinit</code>.</p>
<div class="table-wrapper"><table><thead><tr><th>Keyword</th><th>Introduced in</th><th>Usage</th></tr></thead><tbody>
<tr><td><code>constinit</code></td><td>C++20</td><td>Defines objects that are guaranteed to be initialized with a constant expression.</td></tr>
<tr><td><code>constexpr</code></td><td>C++11</td><td>Indicates that a function or object can be evaluated at compile-time.</td></tr>
<tr><td><code>consteval</code></td><td>C++20</td><td>Similar to <code>constexpr</code>, but functions marked with <code>consteval</code> must be evaluated at compile-time.</td></tr>
</tbody></table>
</div>
<p>In addition to these keywords, C++ also includes several other features that enable compile-time evaluation, such as template metaprogramming and the <code>std::integral_constant</code> class template. These features allow for complex computations and logic to be performed at compile-time, leading to more efficient and optimized code.</p>
<h2 id="performance-boost-with-compile-time-evaluation"><a class="header" href="#performance-boost-with-compile-time-evaluation">Performance boost with compile time evaluation</a></h2>
<p>The ability to perform compile-time evaluation is an important part of the C++ language, as it enables developers to create more efficient and optimized code. The C++ standard includes a number of requirements and guidelines for how these features should be implemented and used. These guidelines help ensure that code that uses compile-time evaluation is portable and can be used across different platforms and architectures.</p>
<p>Compile-time evaluation can help performance in several ways:</p>
<ol>
<li>
<p>Reduce runtime overhead: When values or expressions are evaluated at compile time, the resulting code can be optimized by the compiler. This can reduce the amount of runtime overhead that would be incurred if the same calculations were performed at runtime.</p>
</li>
<li>
<p>Eliminate runtime errors: By evaluating values or expressions at compile time, potential runtime errors can be caught and eliminated before the program is even executed. This can help improve the stability and reliability of the program.</p>
</li>
<li>
<p>Enable constant propagation: When values are known at compile time, they can be propagated throughout the code as constants. This can eliminate unnecessary memory accesses and reduce the number of instructions that need to be executed, leading to faster program execution.</p>
</li>
<li>
<p>Allow for more aggressive optimization: By providing the compiler with information about values and expressions at compile time, the compiler can perform more aggressive optimizations, such as <code>loop unrolling</code>, instruction scheduling, and register allocation. These optimizations can improve program performance by reducing the number of instructions that need to be executed and by maximizing the use of hardware resources.</p>
</li>
</ol>
<h2 id="a-real-life-sample"><a class="header" href="#a-real-life-sample">A real-life sample</a></h2>
<p>The following shows a picture of NEMA-TS2 16-channel Malfunction Management Unit (MMU). Credit: <a href="https://www.flickr.com/photos/robklug/5617557645/">Rob Klug</a></p>
<p><img src="compileval/mmucard.jpg" alt="Image" /></p>
<blockquote>
<p>A Malfunction Management Unit (MMU) is a device utilized in the traffic signal control industry to detect conflicts that may arise when conflicting traffic flows are given right of way simultaneously. This is achieved through the use of a soldering board at the hardware level, which defines the compatibility of each pair of different channels. Essentially, each channel is physically connected to the signal head in the field through load switches, and the compatibility between the channels is relayed to the MMU through this hardware board.</p>
</blockquote>
<p>The following illustrates an application of C++ compile time evaluation approach. It is part of the open source C++ <a href="https://github.com/wxinix/vtc">Virtual Traffic Cabinet Framework (VTC)</a>. VTC framework is developed using modern C++ 20.</p>
<p>The code provides O(1) complexity for returning the start position of a given channel. Note the template functions have zero runtime overhead, while all searching are done at compile time. Apart from the performance benefits, the implementation is concise and generic for any sizable current or future evoluation of MMU compatibility cards.</p>
<pre><code class="language-cpp">/*!
 * The size of channel compatibility set. For example, for Channel 1 of MMU16,
 * its compatibility set includes 1-2, 1-3, 1-4, ..., 1-16, thus the size is 15.
 * @tparam Channel - The given MMU chanel.
 * @tparam MaxChannel - Max number of channels the MMU supports.
 * @return The size of the compatibility set of the given channel.
 */
template&lt;size_t Channel, size_t MaxChannel&gt; requires ((Channel &gt;= 1) &amp;&amp; (Channel &lt;= MaxChannel))
constexpr size_t ChannelSegmentSize()
{
  return (MaxChannel - Channel);
}

/*!
 * The start position (0-based) for the given MMU channel in the fixed-size MMU channel compatibility byte array.
 * @tparam Channel - The given MMU channel.
 * @tparam MaxChannel - Max number of channels the MMU supports.
 * @return The start position (0-based) for the given MMU channel.
 * @remarks MMU channel compatibility is represented by a fixed-size byte array, for
 * MMU16, the byte array has 120 bytes. Each channel has a start position and total number of relevant
 * bytes in the stream describing the channel's compatibility.
 */
template&lt;size_t Channel, size_t MaxChannel = 16&gt; requires ((Channel &gt;= 1) &amp;&amp; (Channel &lt;= MaxChannel))
constexpr size_t ChannelSegmentStartPos()
{
  if constexpr (Channel == 1) {
    return 0;
  } else if constexpr (Channel == 2) {
    return ChannelSegmentSize&lt;1, MaxChannel&gt;();
  } else {
    return ChannelSegmentSize&lt;Channel - 1, MaxChannel&gt;() + ChannelSegmentStartPos&lt;Channel - 1&gt;();
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constexpr"><a class="header" href="#constexpr"><code>constexpr</code></a></h1>
<p><code>constexpr</code> is a C++ keyword that was introduced in C++11 to allow the evaluation of expressions at compile time. It specifies that the value of a <code>variable</code> or <code>function</code> can be computed at compile time, and therefore can be used in places where a constant expression is required.</p>
<h2 id="constexpr-vs-const"><a class="header" href="#constexpr-vs-const"><code>constexpr</code> vs. <code>const</code></a></h2>
<p><code>const</code> only guarantees that the value of a variable cannot be changed after it is initialized, whereas <code>constexpr</code> <em>guarantees</em> that the value of a variable can be computed at <em>compile time</em>. Therefore, <code>constexpr</code> is more powerful than <code>const</code> because it enables the use of constant expressions in more contexts.</p>
<p>Here are some examples of how <code>constexpr</code> can be used:</p>
<pre><code class="language-cpp">constexpr int square(int x) {
    return x * x;
}

constexpr int x = 5;

// y is computed at compile time
constexpr int y = square(x); 

// z is computed at run time
const int z = square(6); 

constexpr int arr_size = 10;

// arr_size is a constant expression
int arr[arr_size]; 

constexpr char c = 'A' + 1;

// static_assert is a compile-time assertion
static_assert(c == 'B', &quot;c should be equal to 'B'&quot;); 
</code></pre>
<h2 id="constexpr-function"><a class="header" href="#constexpr-function"><code>constexpr</code> function</a></h2>
<p>To make a function <code>constexpr</code>, it must meet the following conditions:</p>
<ol>
<li><strong>Must have a Non-void return type.</strong></li>
</ol>
<pre><code class="language-cpp">// Must return a non-void type, like int here
constexpr int square(int x) { 
    return x * x;
}
</code></pre>
<p>A <code>constexpr</code> function cannot have a return type of <code>void</code>, as it must produce a constant expression.</p>
<ol start="2">
<li><strong>Must be defined with <code>constexpr</code> keyword.</strong></li>
</ol>
<pre><code class="language-cpp">// Use the 'constexpr' keyword before the function definition
constexpr int factorial(int n) { 
    return (n &lt;= 1) ? 1 : n * factorial(n - 1);
}
</code></pre>
<ol start="3">
<li><strong>Must not contain any definitions of variables with non-const-qualified types</strong>, unless they are initialized with a constant expression:</li>
</ol>
<pre><code class="language-cpp">// Must use const-qualified type.
constexpr int sum(int a, int b) {
    const int result = a + b; 
    return result;
}

// Non-const variables are allowed as long as they are 
// initialized with a const expression.
// This is only valid when (a + b) produces a constant
// expression.
constexpr int add(int a, int b) {
    // 'sum' is initialized with a constant expression (a + b)
    int sum = a + b; 
    return sum;
}
</code></pre>
<ol start="4">
<li><strong>May include control structures and constructs,</strong> such as <code>if</code>, <code>switch</code>, <code>for</code>, <code>while</code>, and <code>do-while</code> loops, provided they don't violate other <code>constexpr</code> constraints. <code>static_assert</code>, <code>typedef</code>, <code>using</code>, <code>if constexpr</code>, and <code>return</code>are also allowed.</li>
</ol>
<pre><code class="language-cpp">#include &lt;iostream&gt;

constexpr int factorial(int n) {
    int result = 1;
    for (int i = 1; i &lt;= n; ++i) {
        result *= i;
    }
    return result;
}

int main() {
    constexpr auto a = factorial(5);
    return 0;
}
</code></pre>
<p>The generated assembly code confirms that variable <code>a</code> is evaluated at the compile time:</p>
<pre><code class="language-asm">main:                                 
        push    rbp
        mov     rbp, rsp
        mov     dword ptr [rbp - 4], 0
        mov     dword ptr [rbp - 8], 120
        xor     eax, eax
        pop     rbp
        ret
</code></pre>
<ol start="5">
<li><strong>Can only call other <code>constexpr</code> functions.</strong></li>
</ol>
<pre><code class="language-cpp">constexpr int square(int x) {
    return x * x;
}

// Only call other constexpr functions
constexpr int square_sum(int a, int b) {
    return square(a) + square(b); 
}
</code></pre>
<ol start="6">
<li><strong>Must produce constant expressions when called with constant expressions.</strong></li>
</ol>
<pre><code class="language-cpp">#include &lt;iostream&gt;

constexpr int power(int base, int exponent) {
    int result = 1;
    for (int i = 0; i &lt; exponent; ++i) {
        result *= base;
    }
    return result;
}

int main() {
    constexpr auto b = power(2, 5);
    return 0;
}
</code></pre>
<p>The following assembly code confirms that no run time computation is performed when calculating <code>power(2, 5)</code>.</p>
<pre><code class="language-asm">main:
        push    rbp
        mov     rbp, rsp
        mov     dword ptr [rbp - 4], 0
        mov     dword ptr [rbp - 8], 32
        xor     eax, eax
        pop     rbp
        ret
</code></pre>
<ol start="7">
<li><strong>Can modify <code>constexpr</code> object that has a lifetime extends longer than the <code>constexpr</code> function</strong>.</li>
</ol>
<pre><code class="language-cpp">constexpr int next(int x)
{
    return ++x;
}

char buffer[next(5)] = { 0 };
</code></pre>
<h2 id="constructor"><a class="header" href="#constructor">Constructor</a></h2>
<p><code>constexpr</code> constructors in C++ are used to create constant expressions of user-defined types during compile-time. They are useful because they allow for more efficient code by performing computations at compile-time and enabling the usage of user-defined types in other <code>constexpr</code> contexts.</p>
<p><code>constexpr</code> constructors were introduced in C++11, along with the general <code>constexpr</code> specifier.</p>
<p>Conditions (or constraints) for <code>constexpr</code> constructors:</p>
<ol>
<li>The constructor must not be a copy or move constructor.</li>
<li>Every expression and construct used in the constructor must be a constant expression.</li>
<li>Every base class and member of the class must have a <code>constexpr</code> constructor.</li>
<li>Every constructor call and full-expression in the constructor's member initializers must be a constant expression.</li>
</ol>
<p>Here's an example of a <code>constexpr</code> constructor:</p>
<pre><code class="language-cpp">class Point {
public:
    constexpr Point(int x, int y) : x_(x), y_(y) {
        // Since C++14, the body of a constexpr constructor can include
        // other constructs like if statements and loops, as long as they
        // meet the constexpr requirements.
        if (x_ &lt; 0) { x_ = 0; }
        if (y_ &lt; 0) { y_ = 0; }
    }

    constexpr int getX() const { return x_; }
    constexpr int getY() const { return y_; }

private:
    int x_;
    int y_;
};

int main() {
    constexpr Point p1(1, 2);
    constexpr int x = p1.getX();
    constexpr int y = p1.getY();
}
</code></pre>
<h3 id="member-initializer"><a class="header" href="#member-initializer"><em>Member initializer</em></a></h3>
<p>When defining a <code>constexpr</code> constructor,  the constructor's member initializer list must only contain constant expressions. This means that when initializing member variables or calling base class constructors, the expressions used must be evaluable compile-time. This is required to <em>guarantee</em> that the object can be constructed as a constant expression during compile-time.</p>
<p>Here's an example to illustrate this requirement:</p>
<pre><code class="language-cpp">class Base {
public:
    constexpr Base(int value) : value_(value) {}

private:
    int value_;
};

class Derived : public Base {
public:
    // Both initializers are constant expressions
    constexpr Derived(int baseValue, int derivedValue) 
        : Base(baseValue), derivedValue_(derivedValue) {} // Both initializers are constant expressions

private:
    int derivedValue_;
};

int main() {
    // Constructed as a constant expression during compile-time
    constexpr Derived d(1, 2); 
}
</code></pre>
<h2 id="destructor"><a class="header" href="#destructor">Destructor</a></h2>
<p>If a class has a <code>constexpr</code> constructor and is meant to be used in a <code>constexpr</code> context, then the destructor should be trivial. A trivial destructor does not perform any custom actions, allowing the object to be safely used in a <code>constexpr</code> context. </p>
<blockquote>
<p>A destructor is considered trivial if:</p>
<ol>
<li>It is not user-provided (i.e., the compiler generates the destructor implicitly).</li>
<li>The class has no virtual functions or virtual base classes.</li>
<li>All direct base classes have trivial destructors.</li>
<li>For all non-static data members of the class that are of class type (or array thereof), each such class has a trivial destructor.</li>
</ol>
</blockquote>
<p>Here's an example of a class with a <code>constexpr</code> constructor and a trivial destructor:</p>
<pre><code class="language-cpp">class Point {
public:
    constexpr Point(int x, int y) : x_(x), y_(y) {}

    // Destructor is trivial (not user-provided and no custom actions)
    // ~Point() = default;

    constexpr int getX() const { return x_; }
    constexpr int getY() const { return y_; }

private:
    int x_;
    int y_;
};

int main() {
    constexpr Point p(1, 2);
}
</code></pre>
<h2 id="constexpr-function-returning-void"><a class="header" href="#constexpr-function-returning-void"><code>constexpr</code> function returning <code>void</code></a></h2>
<p>A member function of a class can be declared <code>constexpr</code> and have a return type of <code>void</code>, for performing a sequence of actions at compile time. For example:</p>
<pre><code class="language-cpp">class MyClass {
public:
    constexpr void doSomething() {
        myData = 42; // Set a constexpr data member
    }

    constexpr int getMyData() const {
        return myData; // Return the value of the constexpr data member
    }

private:
    int myData = 0; // Define a constexpr data member
};

int main() {
    constexpr MyClass obj;
    obj.doSomething(); // This call is evaluated at compile time
    static_assert(obj.getMyData() == 42, &quot;Unexpected value of myData&quot;);
}
</code></pre>
<p>Note that <code>constexpr void doSomething()</code> does not have to be qualified with <code>const</code>.</p>
<h2 id="precision-of-floating-point-constexpr"><a class="header" href="#precision-of-floating-point-constexpr">Precision of floating-point <code>constexpr</code></a></h2>
<p>In C++11 and later, <code>constexpr</code> functions can compute floating-point expressions and return floating-point values as constant expressions.</p>
<blockquote>
<p>One limitation of <code>constexpr</code> floating-point computations is that they must terminate in a finite number of steps known at compile time, which means that they cannot compute certain mathematical functions or operations that require an infinite number of steps or iterations. Because of this, the use of functions like <code>std::sin</code> and <code>std::sqrt</code> within <code>constexpr</code> functions is not allowed inside <code>constexpr</code> function.</p>
<p>Additionally, the standard imposes specific requirements on the rounding behavior of constexpr floating point operations. For example, if a constexpr floating point operation results in a value that cannot be represented exactly, the result must be rounded in a manner consistent with the floating point rounding mode specified by the implementation.</p>
</blockquote>
<p>The C++ standard requires that <code>constexpr</code> functions produce the same results as their non-<code>constexpr</code> counterparts when called with the same arguments.</p>
<p>This means that if a non-<code>constexpr</code> function performs a floating point computation with a certain precision, a <code>constexpr</code> function that performs the same computation must produce a result that is at least as precise. The standard does not specify a minimum level of precision, but it requires that the result of a <code>constexpr</code> floating point computation be consistent and reproducible, so that the same result is obtained every time the computation is performed.</p>
<p>In practice, the precision of <code>constexpr</code> floating point computations will depend on the compiler and the platform being used. In general, compilers will try to produce <code>constexpr</code> results that are as precise as possible, but there may be cases where the precision is lower than the runtime counterpart due to limitations of the compiler or platform.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stdnumeric_limits"><a class="header" href="#stdnumeric_limits">std::numeric_limits</a></h1>
<p><code>std::numeric_limits</code> is a class template defined in the C++ standard library that provides information about the properties of arithmetic types, such as minimum and maximum representable values, number of significant digits, and whether the type is signed or unsigned.</p>
<p>The <code>std::numeric_limits</code> class template has the following general syntax:</p>
<pre><code class="language-cpp">template&lt;typename T&gt;
class numeric_limits {
public:
    static constexpr bool is_specialized;
    static constexpr T min() noexcept;
    static constexpr T max() noexcept;
    static constexpr T lowest() noexcept;
    static constexpr int digits;
    static constexpr int digits10;
    static constexpr int max_digits10;
    static constexpr bool is_signed;
    static constexpr bool is_integer;
    static constexpr bool is_exact;
    static constexpr int radix;
    static constexpr T epsilon() noexcept;
    static constexpr T round_error() noexcept;
    static constexpr int min_exponent;
    static constexpr int min_exponent10;
    static constexpr int max_exponent;
    static constexpr int max_exponent10;
    static constexpr bool has_infinity;
    static constexpr bool has_quiet_NaN;
    static constexpr bool has_signaling_NaN;
    static constexpr float_denorm_style has_denorm;
    static constexpr bool has_denorm_loss;
    static constexpr T infinity() noexcept;
    static constexpr T quiet_NaN() noexcept;
    static constexpr T signaling_NaN() noexcept;
    static constexpr T denorm_min() noexcept;
};
</code></pre>
<p>The <code>std::numeric_limits</code> class template provides a set of static member functions and constants that can be used to query the properties of the template parameter type <code>T</code>. These functions and constants are all <code>constexpr</code>, which means that they can be evaluated at compile-time and used in constant expressions.</p>
<p>The <code>constexpr</code> specifier is useful for several reasons in the context of <code>std::numeric_limits</code>. For one, it allows the properties of a type to be determined at compile-time, which can be useful for optimization purposes. Additionally, it enables the use of these properties in other <code>constexpr</code> contexts, such as defining other <code>constexpr</code> functions or variables. This can help improve the efficiency and readability of code. For example:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;limits&gt;

template&lt;typename T&gt;
constexpr bool is_power_of_two(T value) {
    return value != 0 &amp;&amp; (value &amp; (value - 1)) == 0;
}

template&lt;typename T&gt;
constexpr T next_power_of_two(T value) {
    static_assert(std::numeric_limits&lt;T&gt;::is_integer, &quot;Type must be an integer&quot;);
    static_assert(std::numeric_limits&lt;T&gt;::is_signed == false, &quot;Type must be unsigned&quot;);

    if (is_power_of_two(value)) {
        return value;
    } else {
        T result = 1;
        while (result &lt; value) {
            result &lt;&lt;= 1;
        }
        return result;
    }
}

int main() {
    constexpr unsigned int x = 31;
    constexpr auto y = next_power_of_two(x);
    std::cout &lt;&lt; &quot;The next power of two after &quot; &lt;&lt; x &lt;&lt; &quot; is &quot; &lt;&lt; y &lt;&lt; '\n';
    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c20-constexpr-math-functions"><a class="header" href="#c20-constexpr-math-functions">C++20 <code>constexpr</code> math functions</a></h1>
<p>In C++20, many math functions from the <code>&lt;cmath&gt;</code> library were made <code>constexpr</code>. This enables complex mathematical operations at compile time, which can lead to more efficient and optimized code.</p>
<p>The main advantage of using <code>constexpr</code> math functions is that they enable calculations at compile time rather than at runtime. This can lead to performance improvements because the compiler can optimize the code based on the known constant values. Additionally, because the values are known at compile time, they can be used in places where a constant expression is needed, such as in array sizes and template arguments.</p>
<p>Here are some important points to remember about <code>constexpr</code> math functions:</p>
<ol>
<li>
<p>Only a subset of math functions from the <code>&lt;cmath&gt;</code> library are <code>constexpr</code> in C++20. Other functions may still be evaluated at runtime.</p>
</li>
<li>
<p>The arguments provided to a <code>constexpr</code> function must be constant expressions themselves. Otherwise, the function call will not be evaluated at compile time.</p>
</li>
<li>
<p><code>constexpr</code> math functions are subject to the same floating-point rounding and accuracy limitations as their runtime counterparts. In other words, you should be aware of potential floating-point inaccuracies when using <code>constexpr</code> functions in calculations.</p>
</li>
<li>
<p>Some compilers may not yet fully support C++20 or all of its <code>constexpr</code> math functions. Be sure to check the documentation of the compiler being used to ensure that it supports the specific functions.</p>
</li>
</ol>
<p>Here is a list of selected math functions that became <code>constexpr</code> in C++20. Note that this list is not exhaustive, but it covers some of the most commonly used functions. Once again, these functions became <code>constexpr</code> in C++20, not C++17.</p>
<p>Here's the table sorted by function name in ascending order:</p>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Description</th><th>Since</th></tr></thead><tbody>
<tr><td><code>abs</code></td><td>Absolute value</td><td>C++20</td></tr>
<tr><td><code>acos</code></td><td>Arc cosine function</td><td>C++20</td></tr>
<tr><td><code>acosh</code></td><td>Inverse hyperbolic cosine function</td><td>C++20</td></tr>
<tr><td><code>asin</code></td><td>Arc sine function</td><td>C++20</td></tr>
<tr><td><code>asinh</code></td><td>Inverse hyperbolic sine function</td><td>C++20</td></tr>
<tr><td><code>atan</code></td><td>Arc tangent function</td><td>C++20</td></tr>
<tr><td><code>atan2</code></td><td>Arc tangent function with two parameters</td><td>C++20</td></tr>
<tr><td><code>atanh</code></td><td>Inverse hyperbolic tangent function</td><td>C++20</td></tr>
<tr><td><code>cbrt</code></td><td>Cube root</td><td>C++20</td></tr>
<tr><td><code>ceil</code></td><td>Ceiling function</td><td>C++20</td></tr>
<tr><td><code>copysign</code></td><td>Copy sign of a number</td><td>C++20</td></tr>
<tr><td><code>cos</code></td><td>Cosine function</td><td>C++20</td></tr>
<tr><td><code>cosh</code></td><td>Hyperbolic cosine function</td><td>C++20</td></tr>
<tr><td><code>div</code></td><td>Integral division</td><td>C++20</td></tr>
<tr><td><code>drem</code></td><td>Deprecated; use remainder instead</td><td>C++20</td></tr>
<tr><td><code>erf</code></td><td>Error function</td><td>C++20</td></tr>
<tr><td><code>erfc</code></td><td>Complementary error function</td><td>C++20</td></tr>
<tr><td><code>exp</code></td><td>Exponential function</td><td>C++20</td></tr>
<tr><td><code>exp2</code></td><td>Base-2 exponential function</td><td>C++20</td></tr>
<tr><td><code>expm1</code></td><td>Exponential function minus 1</td><td>C++20</td></tr>
<tr><td><code>fdim</code></td><td>Positive difference</td><td>C++20</td></tr>
<tr><td><code>floor</code></td><td>Floor function</td><td>C++20</td></tr>
<tr><td><code>fma</code></td><td>Fused multiply-add</td><td>C++20</td></tr>
<tr><td><code>fmax</code></td><td>Maximum of two floating-point values</td><td>C++20</td></tr>
<tr><td><code>fmin</code></td><td>Minimum of two floating-point values</td><td>C++20</td></tr>
<tr><td><code>fmod</code></td><td>Floating-point remainder (modulo)</td><td>C++20</td></tr>
<tr><td><code>frexp</code></td><td>Break floating-point number into fraction</td><td>C++20</td></tr>
<tr><td><code>gamma</code></td><td>Deprecated; use tgamma instead</td><td>C++20</td></tr>
<tr><td><code>gamma_r</code></td><td>Deprecated; use lgamma instead</td><td>C++20</td></tr>
<tr><td><code>hypot</code></td><td>Hypotenuse</td><td>C++20</td></tr>
<tr><td><code>ilogb</code></td><td>Integral logarithm of exponent base-2</td><td>C++20</td></tr>
<tr><td><code>j0</code></td><td>Bessel function of the first kind of order 0</td><td>C++20</td></tr>
<tr><td><code>j1</code></td><td>Bessel function of the first kind of order 1</td><td>C++20</td></tr>
<tr><td><code>jn</code></td><td>Bessel function of the first kind of order n</td><td>C++20</td></tr>
<tr><td><code>ldexp</code></td><td>Multiply by integral power of 2</td><td>C++20</td></tr>
<tr><td><code>lgamma</code></td><td>Natural logarithm of the absolute value of the gamma function</td><td>C++20</td></tr>
<tr><td><code>llrint</code></td><td>Round to long long integral value</td><td>C++20</td></tr>
<tr><td><code>llround</code></td><td>Round to nearest long long integer</td><td>C++20</td></tr>
<tr><td><code>log</code></td><td>Natural logarithm</td><td>C++20</td></tr>
<tr><td><code>log10</code></td><td>Base-10 logarithm</td><td>C++20</td></tr>
<tr><td><code>log1p</code></td><td>Natural logarithm of 1 plus argument</td><td>C++20</td></tr>
<tr><td><code>log2</code></td><td>Base-2 logarithm</td><td>C++20</td></tr>
<tr><td><code>logb</code></td><td>Base-2 logarithm of exponent</td><td>C++20</td></tr>
<tr><td><code>lrint</code></td><td>Round to long integral value</td><td>C++20</td></tr>
<tr><td><code>lround</code></td><td>Round to nearest long integer</td><td>C++20</td></tr>
<tr><td><code>max</code></td><td>Maximum of two values</td><td>C++20</td></tr>
<tr><td><code>min</code></td><td>Minimum of two values</td><td>C++20</td></tr>
<tr><td><code>modf</code></td><td>Decompose a floating-point number into its integer and fractional parts</td><td>C++20</td></tr>
<tr><td><code>nan</code></td><td>Generate quiet NaN</td><td>C++20</td></tr>
<tr><td><code>nearbyint</code></td><td>Round to integral value in current rounding mode</td><td>C++20</td></tr>
<tr><td><code>nextafter</code></td><td>Next representable floating-point value</td><td>C++20</td></tr>
<tr><td><code>nexttoward</code></td><td>Next representable floating-point value toward a long double</td><td>C++20</td></tr>
<tr><td><code>pow</code></td><td>Power function</td><td>C++20</td></tr>
<tr><td><code>remainder</code></td><td>Remainder of the floating-point division</td><td>C++20</td></tr>
<tr><td><code>remquo</code></td><td>Remainder and quotient of the floating-point division</td><td>C++20</td></tr>
<tr><td><code>rint</code></td><td>Round to integral value</td><td>C++20</td></tr>
<tr><td><code>round</code></td><td>Round to nearest integer</td><td>C++20</td></tr>
<tr><td><code>scalb</code></td><td>Deprecated; use scalbn or scalbln instead</td><td>C++20</td></tr>
<tr><td><code>scalbln</code></td><td>Scale floating-point number by a power of FLT_RADIX as a long integer</td><td>C++20</td></tr>
<tr><td><code>scalbn</code></td><td>Scale floating-point number by a power of FLT_RADIX</td><td>C++20</td></tr>
<tr><td><code>significand</code></td><td>Get the significand of a floating-point number</td><td>C++20</td></tr>
<tr><td><code>sin</code></td><td>Sine function</td><td>C++20</td></tr>
<tr><td><code>sinh</code></td><td>Hyperbolic sine function</td><td>C++20</td></tr>
<tr><td><code>sqrt</code></td><td>Square root</td><td>C++20</td></tr>
<tr><td><code>tan</code></td><td>Tangent function</td><td>C++20</td></tr>
<tr><td><code>tanh</code></td><td>Hyperbolic tangent function</td><td>C++20</td></tr>
<tr><td><code>tgamma</code></td><td>Gamma function</td><td>C++20</td></tr>
<tr><td><code>trunc</code></td><td>Truncate function</td><td>C++20</td></tr>
<tr><td><code>y0</code></td><td>Bessel function of the second kind of order 0</td><td>C++20</td></tr>
<tr><td><code>y1</code></td><td>Bessel function of the second kind of order 1</td><td>C++20</td></tr>
<tr><td><code>yn</code></td><td>Bessel function of the second kind of order n</td><td>C++20</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><p>In C++17, lambda expressions can be used as <code>constexpr</code> by default, meaning they can be evaluated at compile-time. This feature enables developers to perform computations at compile-time, reducing runtime overhead and improving performance in certain cases. It can also make the code more readable and easier to understand.</p>
<p>Lambda expressions are anonymous functions that can be defined and used within code. They have the following general syntax:</p>
<pre><code class="language-cpp">[capture](parameters) -&gt; return_type { function_body }
</code></pre>
<h2 id="using-lambda-as-constexpr-in-c17"><a class="header" href="#using-lambda-as-constexpr-in-c17">Using lambda as <code>constexpr</code> in C++17:</a></h2>
<p>Since C++17, lambdas are implicitly <code>constexpr</code> by default, which means they can be used in constant expressions, as long as the lambda body and its captures are constexpr-compatible. Here's an example to illustrate this:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

int main() {
    constexpr auto square = [](int x) {
        return x * x;
    };

    constexpr int result = square(5);
    static_assert(result == 25, &quot;Square of 5 should be 25&quot;);

    std::cout &lt;&lt; &quot;Square of 5: &quot; &lt;&lt; result &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<h2 id="benefits-of-using-lambda-as-constexpr"><a class="header" href="#benefits-of-using-lambda-as-constexpr">Benefits of using lambda as <code>constexpr</code></a></h2>
<ol>
<li>
<p><strong>Compile-time computation</strong>: Using <code>constexpr</code> lambdas can shift computation from runtime to compile-time, potentially improving performance for computationally expensive operations.</p>
</li>
<li>
<p><strong>Readability and expressiveness</strong>: By using lambdas, one can write more expressive and readable code, as functions can be defined and used in-place, right where they are needed.</p>
</li>
<li>
<p><strong>Type inference</strong>: Lambdas can deduce the return type automatically, making the code shorter and easier to understand.</p>
</li>
<li>
<p><strong>Better optimization</strong>: Since the lambda is evaluated at compile-time, the compiler has more opportunities to optimize the code further.</p>
</li>
<li>
<p><strong>Enhanced safety</strong>: Using <code>constexpr</code> ensures that the lambda can only be used in constant expressions, which can help catch errors early in the development process.</p>
</li>
</ol>
<h2 id="runtime-degrading"><a class="header" href="#runtime-degrading">Runtime degrading</a></h2>
<p>A <code>constexpr</code> lambda can degrade into a runtime lambda when it's used in a context that doesn't require a constant expression or when it doesn't meet the requirements for a <code>constexpr</code> function. In such cases, the lambda will be evaluated at runtime instead of compile-time.</p>
<p>Here are some conditions that can cause a <code>constexpr</code> lambda to degrade into a runtime lambda:</p>
<ol>
<li>Non-<code>constexpr</code> parameters or captures: If the lambda captures or accepts non-<code>constexpr</code> variables as parameters, the lambda will not be able to be evaluated at compile-time. For example:</li>
</ol>
<pre><code class="language-cpp">int non_const_var = 10;
auto lambda = [non_const_var](int x) {
    return x * non_const_var;
};
int result = lambda(5); // This will be evaluated at runtime
</code></pre>
<ol start="2">
<li>Non-<code>constexpr</code> expressions in the lambda body: If the lambda body contains expressions that cannot be evaluated at compile-time, the lambda will not be <code>constexpr</code>. For example:</li>
</ol>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cmath&gt;

constexpr auto sqrt_lambda = [](double x) {
    return std::sqrt(x); // std::sqrt is not constexpr (prior to C++20)
};

int main() {
    double result = sqrt_lambda(25.0); // This will be evaluated at runtime
    std::cout &lt;&lt; &quot;Square root of 25: &quot; &lt;&lt; result &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<ol start="3">
<li>Using the lambda in a non-<code>constexpr</code> context: Even if the lambda itself is <code>constexpr</code>, if it is used in a context that doesn't require a constant expression, it will be evaluated at runtime. For example:</li>
</ol>
<pre><code class="language-cpp">constexpr auto square = [](int x) {
    return x * x;
};

int main() {
    int input = 0;
    std::cout &lt;&lt; &quot;Enter an integer: &quot;;
    std::cin &gt;&gt; input;

    int result = square(input); // This will be evaluated at runtime
    std::cout &lt;&lt; &quot;Square of &quot; &lt;&lt; input &lt;&lt; &quot;: &quot; &lt;&lt; result &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<p>In this example, although the <code>square</code> lambda is <code>constexpr</code>, it is used with a runtime input value, so it's evaluated at runtime.</p>
<p>When a <code>constexpr</code> lambda degrades into a runtime lambda, it doesn't cause any errors or warnings. It simply means that the lambda is evaluated at runtime, and the performance advantages and safety guarantees of a <code>constexpr</code> lambda are not achieved.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inlining-constexpr"><a class="header" href="#inlining-constexpr">Inlining constexpr</a></h1>
<p>In C++17, a <code>constexpr</code> static data member is implicitly <code>inline</code>. This means that the static data member has the same address in every translation unit that uses it, and there is no need to provide a separate definition for the data member in a source file. </p>
<p>The following example would produce a linker error pre-C++ 17:</p>
<pre><code class="language-cpp">// MyClass.h
class MyClass {
public:
    static constexpr int myConstExpr = 42;
};

// main.cpp
#include &quot;MyClass.h&quot;
#include &lt;iostream&gt;

void printAddress(const int *ptr);

int main() {
    // Taking the address of myConstExpr, this requires a definition.
    printAddress(&amp;MyClass::myConstExpr); 
    return 0;
}

void printAddress(const int *ptr) {
    std::cout &lt;&lt; &quot;Address of myConstExpr: &quot; &lt;&lt; ptr &lt;&lt; std::endl;
}
</code></pre>
<p>In this case, the address of <code>MyClass::myConstExpr</code> is required, so a separate definition is needed in a source file for pre-C++17:</p>
<pre><code class="language-cpp">// MyClass.cpp (pre-C++17)
#include &quot;MyClass.h&quot;

// Definition in source file required to avoid linker errors
const int MyClass::myConstExpr; 
</code></pre>
<p>However, in C++17, the separate definition is not necessary, as the <code>constexpr</code> static data member is implicitly inlined:</p>
<pre><code class="language-cpp">// MyClass.h (C++17)
class MyClass {
public:
    // Automatically inlined, no separate definition required
    static constexpr int myConstExpr = 42; 
};
</code></pre>
<p>The following code will not produce a linker error for pre-C++17. This is because the compilier just does a compile time replacement for the line <code>std::cout &lt;&lt; &quot;Value of myConstExpr: &quot; &lt;&lt; MyClass::myConstExpr &lt;&lt; std::endl;</code>, directly replacing <code> MyClass::myConstExpr</code> with <code>42</code>. There is no addressing involved, hence no linker error.</p>
<pre><code class="language-cpp">// MyClass.h
class MyClass {
public:
    static constexpr int myConstExpr = 42;
};

// main.cpp
#include &quot;MyClass.h&quot;
#include &lt;iostream&gt;

int main() {
    std::cout &lt;&lt; &quot;Value of myConstExpr: &quot; &lt;&lt; MyClass::myConstExpr &lt;&lt; std::endl;
    return 0;
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conditional-compilation"><a class="header" href="#conditional-compilation">Conditional Compilation</a></h1>
<h2 id="if-constexpr-and-if"><a class="header" href="#if-constexpr-and-if"><code>if constexpr</code> and <code>#if</code></a></h2>
<p>C++'s <code>if constexpr</code> is not directly intended to replace conditional defines (e.g., <code>#ifdef</code> or <code>#if</code>). While they serve somewhat similar purposes, they have different use cases and operate at different stages of the compilation process.</p>
<p><code>#ifdef</code> and <code>#if</code> are preprocessor directives in C++ that allow conditional compilation. They operate at the preprocessing stage, which occurs before the actual compilation. Conditional defines are typically used to conditionally include or exclude sections of code based on compile-time conditions or macros.</p>
<p>On the other hand, <code>if constexpr</code> is a feature introduced in C++17 that allows compile-time evaluation of conditions within the context of template metaprogramming or constexpr functions. It is part of the regular C++ code and is evaluated during the compilation process, not the preprocessing stage. <code>if constexpr</code> allows you to conditionally choose between different branches of code based on compile-time constant expressions.</p>
<p>Here's an example to illustrate the difference:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

#define USE_FEATURE

void doSomething() {
#ifdef USE_FEATURE
    std::cout &lt;&lt; &quot;Feature is enabled.&quot; &lt;&lt; std::endl;
#else
    std::cout &lt;&lt; &quot;Feature is disabled.&quot; &lt;&lt; std::endl;
#endif
}

template &lt;bool UseFeature&gt;
void doSomethingTemplate() {
    if constexpr (UseFeature) {
        std::cout &lt;&lt; &quot;Feature is enabled.&quot; &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; &quot;Feature is disabled.&quot; &lt;&lt; std::endl;
    }
}

int main() {
    doSomething();  // Output depends on the USE_FEATURE macro.

    doSomethingTemplate&lt;true&gt;();  // Output depends on the template argument.
    doSomethingTemplate&lt;false&gt;();

    return 0;
}
</code></pre>
<p>In this example, <code>doSomething()</code> uses a conditional define to determine which section of code to compile based on the <code>USE_FEATURE</code> macro. On the other hand, <code>doSomethingTemplate()</code> is a function template that utilizes <code>if constexpr</code> to conditionally choose between different code branches at compile time based on the template argument.</p>
<p>While <code>if constexpr</code> can sometimes be used to achieve similar conditional behavior as conditional defines, their usage and capabilities are different. Conditional defines are more flexible and can be controlled externally via macros or command-line options, while <code>if constexpr</code> operates within the confines of the C++ code and allows compile-time decision making based on template arguments or constexpr conditions.</p>
<h2 id="short-circuit-behavior"><a class="header" href="#short-circuit-behavior">Short-circuit behavior</a></h2>
<p>Unlike regular <code>if</code> statements, where the short-circuit behavior applies to the evaluation of the condition, <code>if constexpr</code> evaluates the condition at compile-time, and all branches are checked for syntactic correctness regardless of the condition's value.</p>
<p>In this example:</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
void foo(T value) {
    if constexpr (std::is_integral_v&lt;T&gt; &amp;&amp; (value &gt; 0)) {
        // Code specific to integral types and positive values
        // ...
    } else {
        // Code for other cases
        // ...
    }
}
</code></pre>
<p>Both <code>std::is_integral_v&lt;T&gt;</code> and <code>(value &gt; 0)</code> will be evaluated during compilation, regardless of the outcome of the condition. This means that any type-dependent or invalid code inside the discarded branch may still lead to compilation errors.</p>
<h2 id="branch-elimination"><a class="header" href="#branch-elimination">Branch elimination</a></h2>
<p>In an <code>if constexpr</code> statement, the condition is evaluated at compile-time. If the condition is determined to be <code>false</code> during compilation, the code inside the branch that is not taken (either <code>if</code> or <code>else</code>) is discarded by the compiler. The discarded branch is not checked for syntactic correctness or compiled.</p>
<p>This compile-time evaluation and branch elimination make <code>if constexpr</code> useful for conditional compilation and optimizing code based on compile-time conditions.</p>
<p>By discarding the unused branch, the compiler avoids checking its syntax and does not generate any corresponding object code. This can help improve the compile time and reduce the size of the resulting binary executable.</p>
<h2 id="always-provide-else-branch"><a class="header" href="#always-provide-else-branch">Always provide <code>else</code> branch</a></h2>
<p>It is generally a good practice to provide an <code>else</code> branch or alternative handling for all possible cases in an <code>if constexpr</code> statement to avoid potential runtime issues and ensure that all scenarios are properly handled.</p>
<pre><code class="language-cpp">template&lt;class T&gt;
auto subtract(T a, T b) {
    if constexpr (std::is_same&lt;T, double&gt;::value) {
        if (std::abs(a - b) &lt; 0.0001) {
            return 0.0;
        } else {
            return a - b;
        }
    } else if constexpr (std::is_integral&lt;T&gt;::value) {
        return a - b;
    } else {
        static_assert(always_false&lt;T&gt;::value, &quot;Non-handled type for subtract function&quot;);
    }
}
</code></pre>
<p>In this code, both double and integral types are explicitly handled. If a type is used that is neither double nor an integral type, the static_assert will trigger a compile-time error with a clear message, which is generally preferable to a more obscure error about invalid operations. This is a more defensive programming strategy that makes sure all potential types are handled.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constexpr-virtual-method"><a class="header" href="#constexpr-virtual-method"><code>constexpr</code> virtual method</a></h1>
<p>In C++20, virtual methods can be declared as <code>constexpr</code>, enabling their evaluation during compile time. This allows for potential optimizations where the virtual method can be resolved and reduced to a simple assignment without the overhead of a function call. </p>
<blockquote>
<p>Note - such optimizations occur when the static type of the object is known at compile time.</p>
</blockquote>
<p>Consider an example where the base class has a non-<code>constexpr</code> virtual method, but the derived class overrides it as <code>constexpr</code>:</p>
<pre><code class="language-cpp">class Base {
public:
    virtual int getValue() { return 42; }
};

class Derived : public Base {
public:
    constexpr int getValue() override { return 10; }
};
</code></pre>
<p>Suppose an object of the derived class with the static type known at compile time:</p>
<pre><code class="language-cpp">Derived der = Derived();
int value = der.getValue();
</code></pre>
<p>With proper compiler optimizations, the <code>constexpr</code> virtual method <code>getValue</code> can be evaluated at compile time and reduced to a direct assignment without a function call overhead. The resulting assembly code might resemble the following:</p>
<pre><code class="language-assembly">mov DWORD PTR [ebp-4], 10
</code></pre>
<p>This assembly code demonstrates a direct assignment of the constant value <code>10</code> to the variable <code>value</code> without any function call involved. The compiler can determine the value of <code>getValue</code> at compile time, considering the known static type of the object.</p>
<p>It's important to note that the specific optimization and resulting assembly code may vary depending on the compiler, compiler flags, and optimizations enabled. However, with appropriate optimizations, a <code>constexpr</code> virtual method can indeed be optimized to a simple assignment during compile time, avoiding the function call overhead.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="try-catch"><a class="header" href="#try-catch">try-catch</a></h1>
<p>In C++20, the language standard introduced the ability to use try-catch blocks inside constexpr functions. Prior to C++20, constexpr functions were limited to containing only a subset of operations that were considered &quot;constexpr-friendly.&quot; This limitation prevented the use of exceptions, dynamic memory allocation, and other runtime-only features.</p>
<p>With C++20, the restrictions on constexpr functions have been relaxed, and try-catch blocks are now allowed inside constexpr functions. This change allows for more expressive and flexible constexpr functions, enabling them to handle exceptions and perform more complex operations at compile time.</p>
<p>The primary motivation behind allowing try-catch blocks in constexpr functions is to enable error handling and better handling of unexpected situations during compile-time evaluation. It allows constexpr functions to handle exceptions and provide a fallback mechanism in case of errors. This can be useful in scenarios where you want to perform complex computations at compile time, but need to handle potential errors gracefully.</p>
<p>Here's an example that demonstrates the usage of try-catch blocks inside a constexpr function:</p>
<pre><code class="language-cpp">constexpr int divide(int a, int b) {
    try {
        return a / b;
    } catch (...) {
        return 0; // fallback value in case of division by zero or other exceptions
    }
}

int main() {
    constexpr int result = divide(10, 2);
    static_assert(result == 5, &quot;Division failed at compile time!&quot;);
    return 0;
}
</code></pre>
<p>In the above example, the <code>divide</code> function attempts to perform division but handles the potential exception by catching any exception thrown. If an exception occurs, it returns a fallback value of 0.</p>
<p>It's important to note a few caveats and considerations when using try-catch blocks in constexpr functions:</p>
<ol>
<li>Exceptions inside constexpr functions are only evaluated during compile time. If an exception is thrown, the program won't terminate at runtime. Instead, the exception is handled by the constexpr function, and the program continues execution.</li>
<li>The exception handling in constexpr functions is limited to exceptions that are handled within the constexpr function itself. It does not allow for exceptions to propagate to the calling context.</li>
<li>The use of dynamic memory allocation (e.g., <code>new</code>, <code>malloc</code>) is still not allowed in constexpr functions, even with the introduction of try-catch blocks.</li>
</ol>
<p>Overall, the addition of try-catch blocks in constexpr functions in C++20 expands the capabilities of compile-time evaluation and allows for more robust error handling during constexpr computations.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="default-initialization-of-constexpr-objects"><a class="header" href="#default-initialization-of-constexpr-objects">Default Initialization of <code>constexpr</code> Objects</a></h1>
<p>In C++20, the language standard introduced the ability to use trivial default construction for constexpr objects. Trivial default construction means that a constexpr object can be default-initialized without explicitly providing a constructor or initializer.</p>
<p>Here is an example that demonstrates the usage of trivial default construction in a constexpr function:</p>
<pre><code class="language-cpp">struct X {
    bool val;
};

constexpr void f() {
    X x;
}
</code></pre>
<p>The above code only works with C++20. C++ 17 requires that explicit initialization for constexpr objects must be provided to ensure their proper initialization. Here's an example of explicit initializing a constexpr object in C++17:</p>
<pre><code class="language-cpp">struct X {
    bool val;
};

constexpr void f() {
    X x{true}; // Explicit initialization required in C++17
}
</code></pre>
<p>The following example demonstrates the usage of trivial default construction in a more practical scenario:</p>
<pre><code class="language-cpp">#include &lt;array&gt;

constexpr std::array&lt;int, 5&gt; createArray() {
    std::array&lt;int, 5&gt; arr;
    for (int i = 0; i &lt; arr.size(); ++i) {
        arr[i] = i * i;
    }
    return arr;
}

int main() {
    constexpr std::array&lt;int, 5&gt; result = createArray();
    // Use the constexpr array at compile time
    static_assert(result[2] == 4, &quot;Unexpected value at compile time!&quot;);
    return 0;
}
</code></pre>
<p>In this example, the constexpr function <code>createArray</code> creates an array of integers and assigns values to its elements using a loop. The array <code>arr</code> is default-initialized without explicitly providing an initializer because <code>std::array</code> is a trivial type. The function returns the resulting array, which can then be used at compile time.</p>
<p>By allowing trivial default construction for constexpr objects, C++20 simplifies the initialization process for certain types and enables more concise and efficient constexpr code. It can be particularly beneficial when working with trivial types or when initializing objects that don't require explicit initialization before use.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="consteval-and-constinit"><a class="header" href="#consteval-and-constinit"><code>consteval</code> and <code>constinit</code></a></h1>
<h2 id="consteval"><a class="header" href="#consteval"><code>consteval</code></a></h2>
<p><code>consteval</code> keyword was introduced in C++20 as a new kind of function declaration known as a &quot;consteval function.&quot; A consteval function is designed to be evaluated (and must be evaluable) at compile-time within constant expressions.</p>
<p>To be valid, a consteval function must have a literal type, meaning that its type can be used within a constant expression. Additionally, the body of a consteval function must be fully evaluated at compile-time, without any runtime execution. <strong>If these requirements are not met, the compiler will generate an error</strong>.</p>
<p>Here's an example of a consteval function:</p>
<pre><code class="language-cpp">consteval int square(int x) {
    return x * x;
}
</code></pre>
<h3 id="difference-between-consteval-and-constexpr"><a class="header" href="#difference-between-consteval-and-constexpr">Difference between <code>consteval</code> and <code>constexpr</code></a></h3>
<pre><code class="language-cpp">constexpr int add(int x, int y) {
    return x + y;
}

consteval int multiply(int x, int y) {
    return x * y;
}

int main() {
    constexpr int result1 = add(3, 4);        // Evaluates at compile-time
    consteval int result2 = multiply(5, 6);   // Evaluates at compile-time

    int x = 2, y = 3;
    int result3 = add(x, y);                  // Evaluates at runtime

    return 0;
}
</code></pre>
<p>In the code above, the <code>add</code> function is declared as <code>constexpr</code>, allowing it to be evaluated at both compile-time and runtime. The <code>multiply</code> function is declared as <code>consteval</code>, ensuring that it is evaluated strictly at compile-time within constant expressions.</p>
<h2 id="constinit"><a class="header" href="#constinit"><code>constinit</code></a></h2>
<p>The <code>constinit</code> specifier is introduced in C++20 to qualify a variable with static storage duration. A variable marked with <code>constinit</code> specifier must be initialized with compile-time constant expressions and it guarantees that the initialization will be done during the static initialization phase. It prevents the variables with static storage duration to be initialized at runtime.</p>
<ul>
<li>
<p><code>constinit</code> cannot be used together with <code>constexpr</code> or <code>consteval</code> as <code>constinit</code> is used for static initialization of variables, which happens before the program starts the execution, whereas constexpr and consteval are used to evaluate the expression at compile time.</p>
</li>
<li>
<p><code>constinit</code> forces constant initialization of static or thread-local variables. It can help to limit static order initialization fiasco by using precompiled values and well-defined order rather than dynamic initialization and linking order</p>
</li>
<li>
<p><code>constinit</code> does not mean that the object is immutable. <code>constinit</code> variable cannot be used in constant expressions</p>
</li>
</ul>
<pre><code class="language-cpp">#include &lt;array&gt;

// init at compile time
constexpr int compute(int v) { return v*v*v; }
constinit int global = compute(10);

// won't work:
// constinit int another = global;

int main() {
    // but allow to change later...
    global = 100;

    // global is not constant!
    // std::array&lt;int, global&gt; arr;
}
</code></pre>
<pre><code class="language-assembly">main:
 push   rbp
 mov    rbp,rsp
 mov    DWORD PTR [rip+0x2efc],0x64        # 404010 &lt;global&gt;
 mov    eax,0x0
 pop    rbp
 ret
 nop    DWORD PTR [rax+rax*1+0x0]
</code></pre>
<p>The following table summaries all <code>const</code> specifiers (<a href="https://www.cppstories.com/2022/const-options-cpp20/">credit: Bartłomiej Filipek</a>)</p>
<div class="table-wrapper"><table><thead><tr><th>Keyword</th><th>On Auto Variables</th><th>On Static/Thread_Local Variables</th><th>On Functions</th><th>On Constant Expressions</th></tr></thead><tbody>
<tr><td><code>const</code></td><td>Yes</td><td>Yes</td><td>As const member functions</td><td>Sometimes</td></tr>
<tr><td><code>constexpr</code></td><td>Yes or Implicit (in constexpr functions)</td><td>Yes</td><td>To indicate constexpr functions</td><td>Yes</td></tr>
<tr><td><code>consteval</code></td><td>No</td><td>No</td><td>To indicate consteval functions</td><td>Yes (as a result of a function call)</td></tr>
<tr><td><code>constinit</code></td><td>No</td><td>To force constant initialization</td><td>No</td><td>No, a <code>constinit</code> variable is not a constexpr variable</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="stdis_constant_evaluated"><a class="header" href="#stdis_constant_evaluated">std::is_constant_evaluated</a></h1>
<p><code>std::is_constant_evaluated</code> function was introduced in C++20 as a standard library feature. It provides a way to check whether a function is being evaluated in a constant expression context or a non-constant expression context. This feature enables developers to write code that behaves differently during compile-time evaluation compared to runtime execution. </p>
<blockquote>
<p>The motivation behind introducing <code>std::is_constant_evaluated</code> is to allow for explicit compile-time evaluation, which provides more control and flexibility in code execution. It allows developers to optimize certain operations or choose alternate code paths specifically for constant expressions.</p>
</blockquote>
<p>Here's an example that demonstrates the usage of <code>std::is_constant_evaluated</code>:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

void printEvaluationContext() {
    if (std::is_constant_evaluated()) {
        std::cout &lt;&lt; &quot;Constant expression evaluation&quot; &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; &quot;Runtime execution&quot; &lt;&lt; std::endl;
    }
}

constexpr int doubleValue(int value) {
    if (std::is_constant_evaluated()) {
        return value * 2;  // Constant expression evaluation
    } else {
        std::cout &lt;&lt; &quot;Runtime evaluation&quot; &lt;&lt; std::endl;
        return value;      // Runtime execution
    }
}

int main() {
    printEvaluationContext();

    constexpr int result1 = doubleValue(10);
    std::cout &lt;&lt; &quot;Result 1: &quot; &lt;&lt; result1 &lt;&lt; std::endl;

    int value = 20;
    int result2 = doubleValue(value);
    std::cout &lt;&lt; &quot;Result 2: &quot; &lt;&lt; result2 &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="other-c20-enhancements"><a class="header" href="#other-c20-enhancements">Other C++20 Enhancements</a></h1>
<p>In C++20, several enhancements were made to the <code>constexpr</code> feature, including the ability to modify members of a union and the inclusion of certain language constructs like <code>dynamic_cast</code>, <code>typeid</code>, and inlined assembly within <code>constexpr</code> functions.</p>
<h2 id="modifying-members-of-a-union-in-constexpr"><a class="header" href="#modifying-members-of-a-union-in-constexpr">Modifying members of a union in constexpr</a></h2>
<p>In earlier versions of C++, modifying a member of a union within a <code>constexpr</code> context was not allowed. However, starting from C++20, it became possible. Here's an example that demonstrates this:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

union MyUnion {
    int i;
    float f;
};

constexpr int modifyUnionMember(int value) {
    MyUnion u;
    u.i = value;
    return u.f;  // Modify the float member
}

int main() {
    constexpr int modifiedValue = modifyUnionMember(42);
    std::cout &lt;&lt; &quot;Modified value: &quot; &lt;&lt; modifiedValue &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<h2 id="dynamic_cast-and-typeid-within-constexpr"><a class="header" href="#dynamic_cast-and-typeid-within-constexpr"><code>dynamic_cast</code> and <code>typeid</code> within <code>constexpr</code></a></h2>
<p>C++20 also introduced the ability to use <code>dynamic_cast</code> and <code>typeid</code> operators within <code>constexpr</code> functions. This allows for dynamic type checks and type information retrieval during compile-time evaluation. Here's an example:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;typeinfo&gt;

struct Base {
    virtual ~Base() {}
};

struct Derived : Base {};

constexpr bool isDerivedFromBase(const Base* obj) {
    return dynamic_cast&lt;const Derived*&gt;(obj) != nullptr;
}

constexpr const std::type_info&amp; getTypeInfo(const Base* obj) {
    return typeid(*obj);
}

int main() {
    constexpr Base* basePtr = new Derived();
    constexpr bool isDerived = isDerivedFromBase(basePtr);
    constexpr const std::type_info&amp; typeInfo = getTypeInfo(basePtr);

    std::cout &lt;&lt; &quot;Is Derived from Base? &quot; &lt;&lt; isDerived &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Type info: &quot; &lt;&lt; typeInfo.name() &lt;&lt; std::endl;

    delete basePtr;
    return 0;
}
</code></pre>
<h2 id="inlined-assembly-within-constexpr"><a class="header" href="#inlined-assembly-within-constexpr">Inlined assembly within <code>constexpr</code></a></h2>
<p>C++20 also allows the use of inlined assembly within <code>constexpr</code> functions, enabling low-level operations during compile-time evaluation. Here's an example:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

constexpr int addNumbersInlineAssembly(int a, int b) {
    int result;
    asm(&quot;add %[a], %[b];&quot;
        : [result] &quot;=r&quot; (result)
        : [a] &quot;r&quot; (a), [b] &quot;r&quot; (b)
    );
    return result;
}

int main() {
    constexpr int sum = addNumbersInlineAssembly(10, 20);
    std::cout &lt;&lt; &quot;Sum: &quot; &lt;&lt; sum &lt;&lt; std::


</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modern-c-type-deduction-mechanisms"><a class="header" href="#modern-c-type-deduction-mechanisms">Modern C++ Type Deduction Mechanisms</a></h1>
<p>Type deduction allows the compiler to infer types automatically, making code more concise, expressive, and easier to maintain. </p>
<p>From C++11 through C++20, the language has introduced a variety of type deduction capabilities.</p>
<p>This chapter provides a comprehensive overview of modern C++ type deduction. It also highlights best practices and rules to help developers use <code>auto</code>, <code>decltype</code>, and related features effectively.</p>
<p>Mastering type deduction is essential for writing clean, robust, and modern C++ code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-to-type-deduction"><a class="header" href="#introduction-to-type-deduction">Introduction to Type Deduction</a></h1>
<h2 id="what-is-type-deduction"><a class="header" href="#what-is-type-deduction">What is Type Deduction?</a></h2>
<p>The compiler uses type deduction to determine the type of a variable or return value automatically. It eliminates the need for explicitly specifying types.</p>
<p>The most common interface to type deduction is the <code>auto</code> keyword, introduced in C++11.  The compiler infers the type from the initializer:</p>
<pre><code class="language-cpp">auto x = 42; // x is deduced to be int
</code></pre>
<p>The utility of type deduction goes beyond simplifying type declarations. In modern C++, it plays a significant role in templates, <code>decltype</code>, structured bindings, and function return types as well.</p>
<h2 id="why-use-type-deduction"><a class="header" href="#why-use-type-deduction">Why Use Type Deduction?</a></h2>
<h3 id="1-prevents-type-mismatches-and-narrowing-conversions"><a class="header" href="#1-prevents-type-mismatches-and-narrowing-conversions">1. Prevents Type Mismatches and Narrowing Conversions</a></h3>
<p>Using <code>auto</code> ensures the <strong>deduced type exactly matches</strong> the initializer, avoiding silent type conversions or loss of precision.</p>
<pre><code class="language-cpp">int x = 0.1;     // Compiles, but silently truncates to 0
auto y = 0.1;    // y is double — no truncation
</code></pre>
<h3 id="2-encourages-consistent-initialization"><a class="header" href="#2-encourages-consistent-initialization">2. Encourages Consistent Initialization</a></h3>
<p>Because <code>auto</code> requires initialization, it reduces the chance of uninitialized variables:</p>
<pre><code class="language-cpp">auto value;         // ❌ Error — must be initialized
int value;          // ✅ Legal, but uninitialized!
</code></pre>
<h3 id="3-improves-code-maintainability"><a class="header" href="#3-improves-code-maintainability">3. Improves Code Maintainability</a></h3>
<p>If the return type of a function or container changes, <code>auto</code> adapts automatically:</p>
<pre><code class="language-cpp">auto result = myMap.find(key);
// No need to know if it's an iterator or const_iterator
</code></pre>
<p>This makes code more <strong>resilient to API or type changes</strong>.</p>
<h3 id="4-simplifies-opaque-and-long-name-types"><a class="header" href="#4-simplifies-opaque-and-long-name-types">4. Simplifies Opaque and Long-Name Types</a></h3>
<pre><code class="language-cpp">auto comp = [](const std::pair&lt;int, int&gt;&amp; a, const std::pair&lt;int, int&gt;&amp; b) {
    return a.second &gt; b.second;
};

// Creating a priority queue of std::pair&lt;int, int&gt; elements, where:
//  - underlying container is a std::vector&lt;std::pair&lt;int, int&gt;&gt;
//  - comparison function is a custom lambda stored in comp
std::priority_queue&lt;std::pair&lt;int, int&gt;, std::vector&lt;std::pair&lt;int, int&gt;&gt;, decltype(comp)&gt; pq(comp);
</code></pre>
<p>With C++17’s class template argument deduction (CTAD), the same declaration becomes more concise, using <code>auto</code>:</p>
<pre><code class="language-cpp">auto pq = std::priority_queue{
    std::vector&lt;std::pair&lt;int, int&gt;&gt;{},
    comp
};
</code></pre>
<p><code>auto</code> helps avoid repeating long type names:</p>
<pre><code class="language-cpp">std::unordered_map&lt;std::string, std::vector&lt;int&gt;&gt;::iterator it = map.begin();
// becomes
auto it = map.begin();
</code></pre>
<h3 id="5-enables-modern-c-idioms-c11c23"><a class="header" href="#5-enables-modern-c-idioms-c11c23">5. Enables Modern C++ Idioms (C++11–C++23)</a></h3>
<p><code>auto</code> is fundamental for the following idioms:</p>
<ul>
<li>
<p>Range-based <code>for</code> loops</p>
<pre><code class="language-cpp">for (auto&amp; value : container) {
    // Clean and safe iteration
}
</code></pre>
</li>
<li>
<p>Structured bindings</p>
<pre><code class="language-cpp">for (auto&amp; [key, value] : myMap) { ... }
</code></pre>
</li>
<li>
<p>Lambdas and closures</p>
<pre><code class="language-cpp">auto adder = [](int a, int b) { return a + b; };
std::cout &lt;&lt; adder(2, 3); // 5
</code></pre>
</li>
<li>
<p>Trailing return types</p>
<pre><code class="language-cpp">template&lt;typename T, typename U&gt;
auto add(T t, U u) -&gt; decltype(t + u) {
    return t + u;
}
</code></pre>
</li>
<li>
<p><code>decltype(auto)</code> for perfect forwarding</p>
<pre><code class="language-cpp">template&lt;typename T&gt;
decltype(auto) forwardValue(T&amp;&amp; val) {
    return std::forward&lt;T&gt;(val);
}
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-deduction-mechanisms"><a class="header" href="#type-deduction-mechanisms">Type Deduction Mechanisms</a></h1>
<p>The table below summarizes C++ type deduction features and their respective introductions into the language standard:</p>
<div class="table-wrapper"><table><thead><tr><th>Mechanism</th><th>Keyword(s)</th><th>Description</th><th>Introduced</th></tr></thead><tbody>
<tr><td><strong>Function template deduction</strong></td><td>template parameters</td><td>Deduces template types from function arguments</td><td>C++98</td></tr>
<tr><td><strong>Auto type deduction</strong></td><td><code>auto</code></td><td>Deduces type from initializer</td><td>C++11</td></tr>
<tr><td><strong>Exact expression type</strong></td><td><code>decltype</code>, <code>decltype(auto)</code></td><td>Queries the exact type of an expression (w/o evaluating)</td><td>C++11/14</td></tr>
<tr><td><strong>Return type deduction</strong></td><td><code>auto</code>, <code>decltype(auto)</code></td><td>Deduces function return type</td><td>C++14</td></tr>
<tr><td><strong>Lambda parameter deduction</strong></td><td><code>auto</code> in lambda</td><td>Deduces parameter types in generic lambdas</td><td>C++14</td></tr>
<tr><td><strong>Structured bindings</strong></td><td><code>auto</code> with <code>[ ]</code></td><td>Unpacks structured types like tuples</td><td>C++17</td></tr>
<tr><td><strong>Class template arg deduction</strong></td><td>CTAD</td><td>Deduces template types from constructor args</td><td>C++17</td></tr>
<tr><td><strong>Non-type template deduction</strong></td><td><code>auto</code></td><td>Deduce type of constant template parameter</td><td>C++17</td></tr>
<tr><td><strong>Abbreviated function templates</strong></td><td><code>auto</code> in function param</td><td>Template parameter deduction in normal function syntax</td><td>C++20</td></tr>
<tr><td><strong>Constrained deduction</strong></td><td>Concepts + <code>auto</code></td><td>Adds semantic constraints to type deduction</td><td>C++20</td></tr>
<tr><td><strong>Aggregate member with auto</strong></td><td><code>auto</code> in struct/class field</td><td>Supports <code>auto</code> members with initializer in aggregates</td><td>C++20</td></tr>
<tr><td><strong>Compile-time enforcement</strong></td><td><code>consteval</code>, <code>constinit</code></td><td>Restricts deduction to compile-time context</td><td>C++20</td></tr>
</tbody></table>
</div>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<h3 id="auto-type-deduction"><a class="header" href="#auto-type-deduction">Auto Type Deduction</a></h3>
<pre><code class="language-cpp">int i = 42;
auto x = i;   // x is deduced as int
</code></pre>
<p>The auto keyword causes the compiler to deduce x as int, based on the initializer.</p>
<h3 id="decltype-type-query"><a class="header" href="#decltype-type-query">Decltype Type Query</a></h3>
<pre><code class="language-cpp">int i = 42;
decltype(i) y = i;   // y is also int
auto z = (i);         // auto is int, decltype((i)) is int&amp;
</code></pre>
<p><code>decltype</code> determines the type of an expression without evaluating it. Parentheses can influence whether a value or reference type is deduced.</p>
<h3 id="function-template-deduction"><a class="header" href="#function-template-deduction">Function Template Deduction</a></h3>
<pre><code class="language-cpp">template&lt;typename T&gt;
void print(T value) {
    std::cout &lt;&lt; value &lt;&lt; std::endl;
}

print(10);   // T is deduced as int
</code></pre>
<p>Template arguments are deduced from the function call's parameter types.</p>
<h3 id="return-type-deduction"><a class="header" href="#return-type-deduction">Return Type Deduction</a></h3>
<pre><code class="language-cpp">auto add(int a, int b) {
    return a + b;   // return type deduced as int
}
</code></pre>
<p>The compiler infers the return type from the return expression when auto is used.</p>
<h3 id="structured-bindings"><a class="header" href="#structured-bindings">Structured Bindings</a></h3>
<pre><code class="language-cpp">std::tuple&lt;int, double&gt; t{1, 2.0};
auto [a, b] = t;  // a is int, b is double
</code></pre>
<p>Structured bindings destructure compound types into named variables with deduced types.</p>
<h3 id="lambda-parameter-deduction"><a class="header" href="#lambda-parameter-deduction">Lambda Parameter Deduction</a></h3>
<pre><code class="language-cpp">auto lambda = [](auto a, auto b) {
    return a + b;
};
</code></pre>
<p>Generic lambdas deduce parameter types during invocation, functioning similarly to templated callables.</p>
<h3 id="class-template-argument-deduction-ctad"><a class="header" href="#class-template-argument-deduction-ctad">Class Template Argument Deduction (CTAD)</a></h3>
<pre><code class="language-cpp">template&lt;typename T&gt;
struct Wrapper {
    T value;
    Wrapper(T v) : value(v) {}
};

Wrapper w(123);  // T deduced as int
</code></pre>
<p>Constructor arguments guide the deduction of template parameters, eliminating the need for explicit specification.</p>
<h3 id="non-type-template-parameter-nttp-deduction"><a class="header" href="#non-type-template-parameter-nttp-deduction">Non-Type Template Parameter (NTTP) Deduction</a></h3>
<pre><code class="language-cpp"> #include &lt;iostream&gt;

template&lt;auto N&gt;
void f() {
    std::cout &lt;&lt; N &lt;&lt; std::endl;
}

int main() {
    f&lt;5&gt;();     // OK: N is deduced as int
    f&lt;'c'&gt;();   // OK: N is deduced as char
    f&lt;5.0&gt;();   // ❌ Error: double is not a valid non-type template parameter
}
</code></pre>
<p>Starting with C++17, non-type template parameters can use auto to infer both the value and the type. In C++20, non-type template parameters (NTTPs) were enhanced to allow a broader set of types, but floating-point types (float, double, long double) are still not allowed as non-type template parameters.</p>
<p>For example, the following class <code>Color</code> is a literal class type with structural semantics, and can be used as NTTP:</p>
<pre><code class="language-cpp">struct Color {
    int r, g, b;
    constexpr bool operator==(const Color&amp;) const = default;
};

template&lt;Color C&gt;
struct Widget {
    void print() {
        std::cout &lt;&lt; C.r &lt;&lt; &quot;, &quot; &lt;&lt; C.g &lt;&lt; &quot;, &quot; &lt;&lt; C.b &lt;&lt; &quot;\n&quot;;
    }
};

int main() {
    Widget&lt;Color{255, 255, 0}&gt; w; // OK in C++20!
    w.print();
}

</code></pre>
<p>But the following can not:</p>
<pre><code class="language-cpp">struct NonStructural {
    double d;  // ❌ double is not allowed in structural types, due to comparison and representation issues.
    constexpr bool operator==(const NonStructural&amp;) const = default;
};

template&lt;NonStructural N&gt;
struct T {};  // ❌ Error

</code></pre>
<h3 id="abbreviated-function-templates"><a class="header" href="#abbreviated-function-templates">Abbreviated Function Templates</a></h3>
<pre><code class="language-cpp">void log(auto x) {
    std::cout &lt;&lt; x;
}
</code></pre>
<p>Function templates can be expressed using auto in parameter declarations, reducing boilerplate syntax.</p>
<h3 id="concepts-and-constrained-deduction"><a class="header" href="#concepts-and-constrained-deduction">Concepts and Constrained Deduction</a></h3>
<pre><code class="language-cpp">template&lt;typename T&gt;
concept Printable = requires(T t) { std::cout &lt;&lt; t; };

void log(Printable auto x) {
    std::cout &lt;&lt; x;
}
</code></pre>
<p>Concepts restrict template parameters to types satisfying specified requirements. The example ensures that x is printable to an output stream.</p>
<h3 id="aggregate-initialization-with-deduction"><a class="header" href="#aggregate-initialization-with-deduction">Aggregate Initialization with Deduction</a></h3>
<pre><code class="language-cpp">struct Data {
    auto x = 0;   
};
</code></pre>
<p>Since C++20, the use of <code>auto</code> in aggregate member declarations is permitted when accompanied by a default initializer. </p>
<blockquote>
<p>⚠️ In short: A simple struct with public fields and no fancy behavior is usually an aggregate. Prior to C++20, an aggregate does not permit member declaration using <code>auto</code>. But this restriction is relaxed with C++20, as long as a default initializer is provided.</p>
</blockquote>
<h3 id="consteval-and-constinit-impact"><a class="header" href="#consteval-and-constinit-impact"><code>consteval</code> and <code>constinit</code> Impact</a></h3>
<pre><code class="language-cpp">consteval int square(int x) { return x * x; }
</code></pre>
<p>The <code>consteval</code> specifier enforces that the function is evaluated at compile time. This feature is used to guarantee constexpr behavior.</p>
<p><code>consteval</code> does not itself cause type deduction, but it may participate in deduction contexts. For example, if the return value of a consteval function is used to initialize a variable declared with auto, then type deduction will occur based on the result:</p>
<pre><code class="language-cpp">auto y = square(4);  // y deduced as int, square(4) evaluated at compile time
</code></pre>
<p>So here, deduction still happens, just as with any function returning a known type. The twist is: the result must be known at compile time.</p>
<p>On the other hand, <code>constinit</code> ensures that a variable with static storage duration (like globals, static members, etc.) is initialized at compile time. It does not mean the variable is constant (unlike const). It ensures that no dynamic initialization will occur — useful for avoiding the static initialization order fiasco.</p>
<p>Similar to <code>consteval</code>, <code>constinit</code> does not perform type deduction itself. But it can interact with deduction:</p>
<pre><code class="language-cpp">constinit auto z = square(5);  // auto deduces int
</code></pre>
<p>Again, <code>auto</code> deduces the type from the value returned by a <code>consteval</code> function, which satisfies <code>constinit</code>'s compile-time requirement.</p>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Purpose</th><th>Role in Type Deduction</th></tr></thead><tbody>
<tr><td><code>consteval</code></td><td>Requires function to be CT evaluated</td><td>May <strong>influence</strong> deduction (via result value)</td></tr>
<tr><td><code>constinit</code></td><td>Ensures static init is CT</td><td>Works <strong>alongside</strong> deduction, doesn't perform it</td></tr>
<tr><td><code>auto</code></td><td>Deduce type from initializer</td><td>Can use values from <code>consteval</code> or <code>constinit</code></td></tr>
</tbody></table>
</div>
<p>The following example illustrates <code>consteval</code> and <code>constinit</code> putting together:</p>
<pre><code class="language-cpp">consteval int factorial(int n) {
    return (n &lt;= 1) ? 1 : (n * factorial(n - 1));
}

constinit auto fact5 = factorial(5);  // fact5 is int, initialized at compile time
</code></pre>
<h2 id="pitfall-object-slicing"><a class="header" href="#pitfall-object-slicing">Pitfall: Object Slicing</a></h2>
<pre><code class="language-cpp">Base* d = new Derived();
auto b = *d;  // b is Base, object slicing occurs
b.f();        // Calls Base::f(), not Derived::f()
</code></pre>
<p>When deducing by value from a base pointer, object slicing occurs, stripping derived-type behavior.</p>
<p>To preserve polymorphic behavior:</p>
<pre><code class="language-cpp">auto&amp; b = *d; // b is Base&amp;
b.f();        // Calls Derived::f()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-deduction-rules-in-c"><a class="header" href="#type-deduction-rules-in-c">Type Deduction Rules in C++</a></h1>
<p>The <code>auto</code> keyword instructs the compiler to deduce the type of a variable based on its initializer.</p>
<p>However, deduction follows a set of specific rules, especially regarding references, <code>const</code> qualifiers, value categories, and initializer forms. </p>
<p>The following summarizes the key rules with examples and explanations.</p>
<h2 id="rule-1-top-level-cv-qualifiers-are-discarded-during-value-initialization"><a class="header" href="#rule-1-top-level-cv-qualifiers-are-discarded-during-value-initialization">Rule 1: <strong>Top-Level CV Qualifiers Are Discarded During Value Initialization</strong></a></h2>
<p>When <code>auto</code> is used to declare a variable and the initializer is a value (i.e. not a reference or pointer), any top-level <code>const</code> or <code>volatile</code> qualifiers in the initializer's type are ignored.</p>
<pre><code class="language-cpp">const int i = 5;
auto j = i;        // deduced as int, not const int
auto&amp; m = i;       // deduced as const int&amp;, reference preserves cv-qualifier
auto* p = &amp;i;      // deduced as const int*, pointer type retains cv-qualifier
const auto n = j;  // deduced as const int
</code></pre>
<p><strong>Explanation:</strong></p>
<ul>
<li><code>j</code> is deduced as <code>int</code> since top-level <code>const</code> is ignored.</li>
<li>When <code>auto</code> is used with reference (<code>&amp;</code>) or pointer (<code>*</code>), the <code>const</code> qualifier is preserved in the deduced type.</li>
<li><code>const auto</code> applies a new <code>const</code> to the deduced type of <code>auto</code>.</li>
</ul>
<h2 id="rule-2-reference-qualifiers-in-initializers-are-ignored-in-value-declarations"><a class="header" href="#rule-2-reference-qualifiers-in-initializers-are-ignored-in-value-declarations">Rule 2: <strong>Reference Qualifiers in Initializers Are Ignored in Value Declarations</strong></a></h2>
<p>When a variable is initialized using a reference, but the declaration uses <code>auto</code> without a reference, the reference in the initializer is not preserved.</p>
<pre><code class="language-cpp">int i = 5;
int&amp; ref = i;
auto m = ref;  // deduced as int, not int&amp;
</code></pre>
<p><strong>Explanation:</strong><br />
The type of <code>m</code> is <code>int</code> because the reference in <code>ref</code> is discarded during value deduction.</p>
<h2 id="rule-3-universal-references-deduce-lvaluervalue-appropriately"><a class="header" href="#rule-3-universal-references-deduce-lvaluervalue-appropriately">Rule 3: <strong>Universal References Deduce Lvalue/Rvalue Appropriately</strong></a></h2>
<p>When <code>auto&amp;&amp;</code> is used (also known as a universal or forwarding reference), the deduced type depends on the value category of the initializer:</p>
<pre><code class="language-cpp">int i = 5;
auto&amp;&amp; x = i;  // deduced as int&amp;, because i is an lvalue
auto&amp;&amp; y = 10; // deduced as int&amp;&amp;, because 10 is an rvalue
</code></pre>
<p><strong>Explanation:</strong><br />
This behavior uses the reference collapsing rules. Lvalues result in <code>T&amp;</code>, and rvalues result in <code>T&amp;&amp;</code>.</p>
<h2 id="rule-4-array-and-function-types-decay-into-pointers"><a class="header" href="#rule-4-array-and-function-types-decay-into-pointers">Rule 4: <strong>Array and Function Types Decay into Pointers</strong></a></h2>
<p>When <code>auto</code> is used to deduce the type of an array or function, the type is deduced as a pointer.</p>
<pre><code class="language-cpp">int arr[5];
auto a = arr;  // deduced as int*

int sum(int, int);
auto b = sum;  // deduced as int (*)(int, int)
</code></pre>
<p><strong>Explanation:</strong><br />
Array names decay to pointers to the first element, and function names decay to function pointers.</p>
<h2 id="rule-5-deduction-with-list-initialization"><a class="header" href="#rule-5-deduction-with-list-initialization">Rule 5: <strong>Deduction with List Initialization</strong></a></h2>
<p>C++17 introduces more precise rules for <code>auto</code> with list-initialization. The deduction behavior differs between <strong>brace-init</strong> and <strong>brace-init with <code>=</code></strong>.</p>
<h3 id="case-1-direct-list-initialization-auto-x"><a class="header" href="#case-1-direct-list-initialization-auto-x">Case 1: Direct List Initialization (<code>auto x{...}</code>)</a></h3>
<pre><code class="language-cpp">auto x1{1};       // deduced as int
auto x2{1, 2};    // error: more than one element
</code></pre>
<ul>
<li>If a single element is used, the type is deduced from that element.</li>
<li>Multiple elements are not permitted—this results in a compilation error.</li>
</ul>
<h3 id="case-2-copy-list-initialization-auto-x--"><a class="header" href="#case-2-copy-list-initialization-auto-x--">Case 2: Copy List Initialization (<code>auto x = {...}</code>)</a></h3>
<pre><code class="language-cpp">auto y1 = {1};       // deduced as std::initializer_list&lt;int&gt;
auto y2 = {1, 2};    // deduced as std::initializer_list&lt;int&gt;
auto y3 = {1, 2.0};  // error: conflicting types, cannot deduce common T
</code></pre>
<ul>
<li>If multiple elements of the same type are used, the type is deduced as <code>std::initializer_list&lt;T&gt;</code>.</li>
<li>If the types differ, deduction fails due to type mismatch.</li>
</ul>
<h2 id="pitfall-object-slicing-with-auto"><a class="header" href="#pitfall-object-slicing-with-auto">Pitfall: Object Slicing with <code>auto</code></a></h2>
<pre><code class="language-cpp">class Base {
public:
    virtual void f() { std::cout &lt;&lt; &quot;Base::f()&quot; &lt;&lt; std::endl; }
};

class Derived : public Base {
public:
    void f() override { std::cout &lt;&lt; &quot;Derived::f()&quot; &lt;&lt; std::endl; }
};

Base* d = new Derived();
auto b = *d;   // deduced as Base (value)
b.f();         // calls Base::f() due to object slicing
</code></pre>
<p><strong>Explanation:</strong></p>
<ul>
<li><code>*d</code> yields a <code>Base&amp;</code>, but since <code>b</code> is declared with <code>auto</code> (not <code>auto&amp;</code>), the result is value-initialized.</li>
<li>This results in <strong>object slicing</strong>, where the <code>Derived</code> part of the object is sliced off, and <code>b</code> becomes a pure <code>Base</code> object.</li>
<li>As a result, the virtual function call resolves to <code>Base::f()</code>.</li>
</ul>
<p>To preserve polymorphism:</p>
<pre><code class="language-cpp">auto&amp; b = *d;  // deduced as Base&amp;
b.f();         // correctly calls Derived::f()
</code></pre>
<h2 id="summary-table"><a class="header" href="#summary-table">Summary Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Scenario</th><th>Deduction Result</th></tr></thead><tbody>
<tr><td><code>auto j = const int</code></td><td><code>int</code> (cv removed)</td></tr>
<tr><td><code>auto&amp; j = const int</code></td><td><code>const int&amp;</code> (cv preserved)</td></tr>
<tr><td><code>auto m = ref</code> where <code>ref</code> is <code>int&amp;</code></td><td><code>int</code></td></tr>
<tr><td><code>auto&amp;&amp; m = lvalue</code></td><td><code>T&amp;</code></td></tr>
<tr><td><code>auto&amp;&amp; m = rvalue</code></td><td><code>T&amp;&amp;</code></td></tr>
<tr><td><code>auto m = array</code></td><td><code>pointer to element type</code></td></tr>
<tr><td><code>auto m = function</code></td><td><code>function pointer</code></td></tr>
<tr><td><code>auto x = {1, 2}</code></td><td><code>std::initializer_list&lt;int&gt;</code></td></tr>
<tr><td><code>auto x{1, 2}</code></td><td>error</td></tr>
<tr><td><code>auto x = {1, 2.0}</code></td><td>error</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h1>
<p>Using <code>auto</code> can greatly improve code clarity and reduce verbosity — but it should be used <strong>judiciously</strong>. Here are guidelines for when <code>auto</code> is beneficial:</p>
<h2 id="when-to-use-auto"><a class="header" href="#when-to-use-auto">When to Use <code>auto</code></a></h2>
<h3 id="when-the-type-is-obvious-from-the-initializer"><a class="header" href="#when-the-type-is-obvious-from-the-initializer">When the Type Is <strong>Obvious</strong> from the Initializer</a></h3>
<p>Use <code>auto</code> when the type is clear and unambiguous:</p>
<pre><code class="language-cpp">auto i = 10;                      // Clearly an int
auto name = std::string(&quot;John&quot;); // Obvious string construction
</code></pre>
<p>Also ideal for range-based loops and iterator declarations:</p>
<pre><code class="language-cpp">for (auto it = container.begin(); it != container.end(); ++it) {
    // Avoids long iterator type
}
</code></pre>
<h3 id="when-the-type-is-long-or-tedious-to-write"><a class="header" href="#when-the-type-is-long-or-tedious-to-write">When the Type Is <strong>Long or Tedious to Write</strong></a></h3>
<p><code>auto</code> helps avoid unnecessarily verbose or complex type declarations:</p>
<pre><code class="language-cpp">auto pair = std::make_pair(42, &quot;answer&quot;);
auto mapIter = std::unordered_map&lt;int, std::vector&lt;std::string&gt;&gt;::iterator{};
</code></pre>
<h3 id="when-dealing-with-lambdas-or-callable-objects"><a class="header" href="#when-dealing-with-lambdas-or-callable-objects">When Dealing with <strong>Lambdas or Callable Objects</strong></a></h3>
<pre><code class="language-cpp">auto lambda = [](int x, int y) { return x + y; };

auto boundFunc = std::bind(sum, 5, std::placeholders::_1);
</code></pre>
<h3 id="when-working-with-templates-stl-iterators-or-ranges"><a class="header" href="#when-working-with-templates-stl-iterators-or-ranges">When Working with <strong>Templates, STL Iterators, or Ranges</strong></a></h3>
<p>Using <code>auto</code> prevents clutter from deeply nested or templated types:</p>
<pre><code class="language-cpp">auto result = someTemplateFunction&lt;T, U&gt;(arg1, arg2);

for (auto&amp; [key, value] : myMap) {
    // Structured bindings with auto make this much cleaner
}
</code></pre>
<h2 id="when-to-avoid-auto"><a class="header" href="#when-to-avoid-auto">When to <strong>Avoid</strong> <code>auto</code></a></h2>
<h3 id="when-it-makes-the-code-ambiguous-or-unclear"><a class="header" href="#when-it-makes-the-code-ambiguous-or-unclear">When It Makes the Code <strong>Ambiguous or Unclear</strong>:</a></h3>
<pre><code class="language-cpp">auto x = getValue();  // What type is x? Unclear without looking up getValue()
</code></pre>
<h3 id="when-explicit-typing-is-critical-for-readability-or-correctness"><a class="header" href="#when-explicit-typing-is-critical-for-readability-or-correctness">When Explicit Typing is Critical for <strong>Readability or Correctness</strong>:</a></h3>
<pre><code class="language-cpp">int count = 0;  // More readable than auto when you want to emphasize the type
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
