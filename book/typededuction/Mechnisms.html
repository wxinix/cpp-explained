<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Mechanisms - Modern C++ Explained</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../section-lines.css">
        <link rel="stylesheet" href="../version-commit.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Preface</a></li><li class="chapter-item expanded affix "><li class="part-title">Modern C++ Elements</li><li class="chapter-item expanded "><a href="../primitive/index.html">Fundamental Data Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../primitive/IntTypes.html">Integer Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../primitive/IntTypes_longlong.html">Integer Type long long</a></li></ol></li><li class="chapter-item expanded "><a href="../primitive/CharTypes.html">Character Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../primitive/CharTypes_CharSetsEncodings.html">Character Sets and Encodings</a></li><li class="chapter-item expanded "><a href="../primitive/CharTypes_NewCharTypes.html">New Character Types</a></li><li class="chapter-item expanded "><a href="../primitive/CharTypes_StringLiteralCat.html">Automatic String Literal Concatenation</a></li><li class="chapter-item expanded "><a href="../primitive/CharTypes_LibrarySuppor.html">Library Support</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../namespace/index.html">Namespace</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../namespace/InlineNamespace.html">Inline Namespace</a></li><li class="chapter-item expanded "><a href="../namespace/NewNestedNamespaceSyntax.html">New Nested Namespace Syntax</a></li><li class="chapter-item expanded "><a href="../namespace/UnnamedNamespace.html">Unnamed Namespace</a></li><li class="chapter-item expanded "><a href="../namespace/MergedNamespace.html">Merged Namespace</a></li><li class="chapter-item expanded "><a href="../namespace/GlobalNamespace.html">Global Namespace</a></li></ol></li><li class="chapter-item expanded "><a href="../compileval/index.html">Compile Time Evaluation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../compileval/Constexpr.html">constexpr</a></li><li class="chapter-item expanded "><a href="../compileval/NumericLimit.html">std::numeric_limits</a></li><li class="chapter-item expanded "><a href="../compileval/MathFunctions.html">Math functions</a></li><li class="chapter-item expanded "><a href="../compileval/Lambdas.html">Lambdas</a></li><li class="chapter-item expanded "><a href="../compileval/InliningConstExpr.html">Inlining constexpr</a></li><li class="chapter-item expanded "><a href="../compileval/ConditionalCompilation.html">Conditional Compilation </a></li><li class="chapter-item expanded "><a href="../compileval/VirtualFunctions.html">Virtual Functions</a></li><li class="chapter-item expanded "><a href="../compileval/TryCatch.html">try-catch </a></li><li class="chapter-item expanded "><a href="../compileval/DefaultInit.html">Initialization of constexpr Object</a></li><li class="chapter-item expanded "><a href="../compileval/ConstEvalAndConstInit.html">consteval and constinit</a></li><li class="chapter-item expanded "><a href="../compileval/StdIsConstant.html">std::is_constant_evaluated</a></li><li class="chapter-item expanded "><a href="../compileval/OtherEnhancements.html">Other Enhancements</a></li></ol></li><li class="chapter-item expanded "><a href="../typededuction/index.html">Type Deduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../typededuction/Introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="../typededuction/Mechnisms.html" class="active">Mechanisms</a></li><li class="chapter-item expanded "><a href="../typededuction/Rules.html">Rules</a></li><li class="chapter-item expanded "><a href="../typededuction/BestPractices.html">Best Practices</a></li></ol></li><li class="chapter-item expanded "><a href="../typequery/index.html">Type Query</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../typequery/Introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="../typequery/Mechnisms.html">Mechanisms</a></li><li class="chapter-item expanded "><a href="../typequery/Rules.html">Rules</a></li><li class="chapter-item expanded "><a href="../typequery/BestPractices.html">Best Practices</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Meta-template Programming</li><li class="chapter-item expanded affix "><li class="part-title">Algorithms</li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Modern C++ Explained</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/wxinix/cpp-explained" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="type-deduction-mechanisms"><a class="header" href="#type-deduction-mechanisms">Type Deduction Mechanisms</a></h1>
<p>The table below summarizes C++ type deduction features and their respective introductions into the language standard:</p>
<div class="table-wrapper"><table><thead><tr><th>Mechanism</th><th>Keyword(s)</th><th>Description</th><th>Introduced</th></tr></thead><tbody>
<tr><td><strong>Function template deduction</strong></td><td>template parameters</td><td>Deduces template types from function arguments</td><td>C++98</td></tr>
<tr><td><strong>Auto type deduction</strong></td><td><code>auto</code></td><td>Deduces type from initializer</td><td>C++11</td></tr>
<tr><td><strong>Exact expression type</strong></td><td><code>decltype</code>, <code>decltype(auto)</code></td><td>Queries the exact type of an expression (w/o evaluating)</td><td>C++11/14</td></tr>
<tr><td><strong>Return type deduction</strong></td><td><code>auto</code>, <code>decltype(auto)</code></td><td>Deduces function return type</td><td>C++14</td></tr>
<tr><td><strong>Lambda parameter deduction</strong></td><td><code>auto</code> in lambda</td><td>Deduces parameter types in generic lambdas</td><td>C++14</td></tr>
<tr><td><strong>Structured bindings</strong></td><td><code>auto</code> with <code>[ ]</code></td><td>Unpacks structured types like tuples</td><td>C++17</td></tr>
<tr><td><strong>Class template arg deduction</strong></td><td>CTAD</td><td>Deduces template types from constructor args</td><td>C++17</td></tr>
<tr><td><strong>Non-type template deduction</strong></td><td><code>auto</code></td><td>Deduce type of constant template parameter</td><td>C++17</td></tr>
<tr><td><strong>Abbreviated function templates</strong></td><td><code>auto</code> in function param</td><td>Template parameter deduction in normal function syntax</td><td>C++20</td></tr>
<tr><td><strong>Constrained deduction</strong></td><td>Concepts + <code>auto</code></td><td>Adds semantic constraints to type deduction</td><td>C++20</td></tr>
<tr><td><strong>Aggregate member with auto</strong></td><td><code>auto</code> in struct/class field</td><td>Supports <code>auto</code> members with initializer in aggregates</td><td>C++20</td></tr>
<tr><td><strong>Compile-time enforcement</strong></td><td><code>consteval</code>, <code>constinit</code></td><td>Restricts deduction to compile-time context</td><td>C++20</td></tr>
</tbody></table>
</div>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<h3 id="auto-type-deduction"><a class="header" href="#auto-type-deduction">Auto Type Deduction</a></h3>
<pre><code class="language-cpp">int i = 42;
auto x = i;   // x is deduced as int
</code></pre>
<p>The auto keyword causes the compiler to deduce x as int, based on the initializer.</p>
<h3 id="decltype-type-query"><a class="header" href="#decltype-type-query">Decltype Type Query</a></h3>
<pre><code class="language-cpp">int i = 42;
decltype(i) y = i;   // y is also int
auto z = (i);         // auto is int, decltype((i)) is int&amp;
</code></pre>
<p><code>decltype</code> determines the type of an expression without evaluating it. Parentheses can influence whether a value or reference type is deduced.</p>
<h3 id="function-template-deduction"><a class="header" href="#function-template-deduction">Function Template Deduction</a></h3>
<pre><code class="language-cpp">template&lt;typename T&gt;
void print(T value) {
    std::cout &lt;&lt; value &lt;&lt; std::endl;
}

print(10);   // T is deduced as int
</code></pre>
<p>Template arguments are deduced from the function call's parameter types.</p>
<h3 id="return-type-deduction"><a class="header" href="#return-type-deduction">Return Type Deduction</a></h3>
<pre><code class="language-cpp">auto add(int a, int b) {
    return a + b;   // return type deduced as int
}
</code></pre>
<p>The compiler infers the return type from the return expression when auto is used.</p>
<h3 id="structured-bindings"><a class="header" href="#structured-bindings">Structured Bindings</a></h3>
<pre><code class="language-cpp">std::tuple&lt;int, double&gt; t{1, 2.0};
auto [a, b] = t;  // a is int, b is double
</code></pre>
<p>Structured bindings destructure compound types into named variables with deduced types.</p>
<h3 id="lambda-parameter-deduction"><a class="header" href="#lambda-parameter-deduction">Lambda Parameter Deduction</a></h3>
<pre><code class="language-cpp">auto lambda = [](auto a, auto b) {
    return a + b;
};
</code></pre>
<p>Generic lambdas deduce parameter types during invocation, functioning similarly to templated callables.</p>
<h3 id="class-template-argument-deduction-ctad"><a class="header" href="#class-template-argument-deduction-ctad">Class Template Argument Deduction (CTAD)</a></h3>
<pre><code class="language-cpp">template&lt;typename T&gt;
struct Wrapper {
    T value;
    Wrapper(T v) : value(v) {}
};

Wrapper w(123);  // T deduced as int
</code></pre>
<p>Constructor arguments guide the deduction of template parameters, eliminating the need for explicit specification.</p>
<h3 id="non-type-template-parameter-nttp-deduction"><a class="header" href="#non-type-template-parameter-nttp-deduction">Non-Type Template Parameter (NTTP) Deduction</a></h3>
<pre><code class="language-cpp"> #include &lt;iostream&gt;

template&lt;auto N&gt;
void f() {
    std::cout &lt;&lt; N &lt;&lt; std::endl;
}

int main() {
    f&lt;5&gt;();     // OK: N is deduced as int
    f&lt;'c'&gt;();   // OK: N is deduced as char
    f&lt;5.0&gt;();   // ❌ Error: double is not a valid non-type template parameter
}
</code></pre>
<p>Starting with C++17, non-type template parameters can use auto to infer both the value and the type. In C++20, non-type template parameters (NTTPs) were enhanced to allow a broader set of types, but floating-point types (float, double, long double) are still not allowed as non-type template parameters.</p>
<p>For example, the following class <code>Color</code> is a literal class type with structural semantics, and can be used as NTTP:</p>
<pre><code class="language-cpp">struct Color {
    int r, g, b;
    constexpr bool operator==(const Color&amp;) const = default;
};

template&lt;Color C&gt;
struct Widget {
    void print() {
        std::cout &lt;&lt; C.r &lt;&lt; &quot;, &quot; &lt;&lt; C.g &lt;&lt; &quot;, &quot; &lt;&lt; C.b &lt;&lt; &quot;\n&quot;;
    }
};

int main() {
    Widget&lt;Color{255, 255, 0}&gt; w; // OK in C++20!
    w.print();
}

</code></pre>
<p>But the following can not:</p>
<pre><code class="language-cpp">struct NonStructural {
    double d;  // ❌ double is not allowed in structural types, due to comparison and representation issues.
    constexpr bool operator==(const NonStructural&amp;) const = default;
};

template&lt;NonStructural N&gt;
struct T {};  // ❌ Error

</code></pre>
<h3 id="abbreviated-function-templates"><a class="header" href="#abbreviated-function-templates">Abbreviated Function Templates</a></h3>
<pre><code class="language-cpp">void log(auto x) {
    std::cout &lt;&lt; x;
}
</code></pre>
<p>Function templates can be expressed using auto in parameter declarations, reducing boilerplate syntax.</p>
<h3 id="concepts-and-constrained-deduction"><a class="header" href="#concepts-and-constrained-deduction">Concepts and Constrained Deduction</a></h3>
<pre><code class="language-cpp">template&lt;typename T&gt;
concept Printable = requires(T t) { std::cout &lt;&lt; t; };

void log(Printable auto x) {
    std::cout &lt;&lt; x;
}
</code></pre>
<p>Concepts restrict template parameters to types satisfying specified requirements. The example ensures that x is printable to an output stream.</p>
<h3 id="aggregate-initialization-with-deduction"><a class="header" href="#aggregate-initialization-with-deduction">Aggregate Initialization with Deduction</a></h3>
<pre><code class="language-cpp">struct Data {
    auto x = 0;   
};
</code></pre>
<p>Since C++20, the use of <code>auto</code> in aggregate member declarations is permitted when accompanied by a default initializer. </p>
<blockquote>
<p>⚠️ In short: A simple struct with public fields and no fancy behavior is usually an aggregate. Prior to C++20, an aggregate does not permit member declaration using <code>auto</code>. But this restriction is relaxed with C++20, as long as a default initializer is provided.</p>
</blockquote>
<h3 id="consteval-and-constinit-impact"><a class="header" href="#consteval-and-constinit-impact"><code>consteval</code> and <code>constinit</code> Impact</a></h3>
<pre><code class="language-cpp">consteval int square(int x) { return x * x; }
</code></pre>
<p>The <code>consteval</code> specifier enforces that the function is evaluated at compile time. This feature is used to guarantee constexpr behavior.</p>
<p><code>consteval</code> does not itself cause type deduction, but it may participate in deduction contexts. For example, if the return value of a consteval function is used to initialize a variable declared with auto, then type deduction will occur based on the result:</p>
<pre><code class="language-cpp">auto y = square(4);  // y deduced as int, square(4) evaluated at compile time
</code></pre>
<p>So here, deduction still happens, just as with any function returning a known type. The twist is: the result must be known at compile time.</p>
<p>On the other hand, <code>constinit</code> ensures that a variable with static storage duration (like globals, static members, etc.) is initialized at compile time. It does not mean the variable is constant (unlike const). It ensures that no dynamic initialization will occur — useful for avoiding the static initialization order fiasco.</p>
<p>Similar to <code>consteval</code>, <code>constinit</code> does not perform type deduction itself. But it can interact with deduction:</p>
<pre><code class="language-cpp">constinit auto z = square(5);  // auto deduces int
</code></pre>
<p>Again, <code>auto</code> deduces the type from the value returned by a <code>consteval</code> function, which satisfies <code>constinit</code>'s compile-time requirement.</p>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Purpose</th><th>Role in Type Deduction</th></tr></thead><tbody>
<tr><td><code>consteval</code></td><td>Requires function to be CT evaluated</td><td>May <strong>influence</strong> deduction (via result value)</td></tr>
<tr><td><code>constinit</code></td><td>Ensures static init is CT</td><td>Works <strong>alongside</strong> deduction, doesn't perform it</td></tr>
<tr><td><code>auto</code></td><td>Deduce type from initializer</td><td>Can use values from <code>consteval</code> or <code>constinit</code></td></tr>
</tbody></table>
</div>
<p>The following example illustrates <code>consteval</code> and <code>constinit</code> putting together:</p>
<pre><code class="language-cpp">consteval int factorial(int n) {
    return (n &lt;= 1) ? 1 : (n * factorial(n - 1));
}

constinit auto fact5 = factorial(5);  // fact5 is int, initialized at compile time
</code></pre>
<h2 id="pitfall-object-slicing"><a class="header" href="#pitfall-object-slicing">Pitfall: Object Slicing</a></h2>
<pre><code class="language-cpp">Base* d = new Derived();
auto b = *d;  // b is Base, object slicing occurs
b.f();        // Calls Base::f(), not Derived::f()
</code></pre>
<p>When deducing by value from a base pointer, object slicing occurs, stripping derived-type behavior.</p>
<p>To preserve polymorphic behavior:</p>
<pre><code class="language-cpp">auto&amp; b = *d; // b is Base&amp;
b.f();        // Calls Derived::f()
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../typededuction/Introduction.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../typededuction/Rules.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../typededuction/Introduction.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../typededuction/Rules.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
