<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>constexpr - Modern C++ Explained</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../section-lines.css">
        <link rel="stylesheet" href="../version-commit.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Modern C++ Explained</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/wxinix/cpp-explained" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="constexpr"><a class="header" href="#constexpr"><code>constexpr</code></a></h1>
<p><code>constexpr</code> is a C++ keyword that was introduced in C++11 to allow the evaluation of expressions at compile time. It specifies that the value of a <code>variable</code> or <code>function</code> can be computed at compile time, and therefore can be used in places where a constant expression is required.</p>
<h2 id="constexpr-vs-const"><a class="header" href="#constexpr-vs-const"><code>constexpr</code> vs. <code>const</code></a></h2>
<p><code>const</code> only guarantees that the value of a variable cannot be changed after it is initialized, whereas <code>constexpr</code> <em>guarantees</em> that the value of a variable can be computed at <em>compile time</em>. Therefore, <code>constexpr</code> is more powerful than <code>const</code> because it enables the use of constant expressions in more contexts.</p>
<p>Here are some examples of how <code>constexpr</code> can be used:</p>
<pre><code class="language-cpp">constexpr int square(int x) {
    return x * x;
}

constexpr int x = 5;

// y is computed at compile time
constexpr int y = square(x); 

// z is computed at run time
const int z = square(6); 

constexpr int arr_size = 10;

// arr_size is a constant expression
int arr[arr_size]; 

constexpr char c = 'A' + 1;

// static_assert is a compile-time assertion
static_assert(c == 'B', "c should be equal to 'B'"); 
</code></pre>
<h2 id="constexpr-function"><a class="header" href="#constexpr-function"><code>constexpr</code> function</a></h2>
<p>To make a function <code>constexpr</code>, it must meet the following conditions:</p>
<ol>
<li><strong>Must have a Non-void return type.</strong></li>
</ol>
<pre><code class="language-cpp">// Must return a non-void type, like int here
constexpr int square(int x) { 
    return x * x;
}
</code></pre>
<p>A <code>constexpr</code> function cannot have a return type of <code>void</code>, as it must produce a constant expression.</p>
<ol start="2">
<li><strong>Must be defined with <code>constexpr</code> keyword.</strong></li>
</ol>
<pre><code class="language-cpp">// Use the 'constexpr' keyword before the function definition
constexpr int factorial(int n) { 
    return (n &lt;= 1) ? 1 : n * factorial(n - 1);
}
</code></pre>
<ol start="3">
<li><strong>Must not contain any definitions of variables with non-const-qualified types</strong>, unless they are initialized with a constant expression:</li>
</ol>
<pre><code class="language-cpp">// Must use const-qualified type.
constexpr int sum(int a, int b) {
    const int result = a + b; 
    return result;
}

// Non-const variables are allowed as long as they are 
// initialized with a const expression.
// This is only valid when (a + b) produces a constant
// expression.
constexpr int add(int a, int b) {
    // 'sum' is initialized with a constant expression (a + b)
    int sum = a + b; 
    return sum;
}
</code></pre>
<ol start="4">
<li><strong>May include control structures and constructs,</strong> such as <code>if</code>, <code>switch</code>, <code>for</code>, <code>while</code>, and <code>do-while</code> loops, provided they don't violate other <code>constexpr</code> constraints. <code>static_assert</code>, <code>typedef</code>, <code>using</code>, <code>if constexpr</code>, and <code>return</code>are also allowed.</li>
</ol>
<pre><code class="language-cpp">#include &lt;iostream&gt;

constexpr int factorial(int n) {
    int result = 1;
    for (int i = 1; i &lt;= n; ++i) {
        result *= i;
    }
    return result;
}

int main() {
    constexpr auto a = factorial(5);
    return 0;
}
</code></pre>
<p>The generated assembly code confirms that variable <code>a</code> is evaluated at the compile time:</p>
<pre><code class="language-asm">main:                                 
        push    rbp
        mov     rbp, rsp
        mov     dword ptr [rbp - 4], 0
        mov     dword ptr [rbp - 8], 120
        xor     eax, eax
        pop     rbp
        ret
</code></pre>
<ol start="5">
<li><strong>Can only call other <code>constexpr</code> functions.</strong></li>
</ol>
<pre><code class="language-cpp">constexpr int square(int x) {
    return x * x;
}

// Only call other constexpr functions
constexpr int square_sum(int a, int b) {
    return square(a) + square(b); 
}
</code></pre>
<ol start="6">
<li><strong>Must produce constant expressions when called with constant expressions.</strong></li>
</ol>
<pre><code class="language-cpp">#include &lt;iostream&gt;

constexpr int power(int base, int exponent) {
    int result = 1;
    for (int i = 0; i &lt; exponent; ++i) {
        result *= base;
    }
    return result;
}

int main() {
    constexpr auto b = power(2, 5);
    return 0;
}
</code></pre>
<p>The following assembly code confirms that no run time computation is performed when calculating <code>power(2, 5)</code>.</p>
<pre><code class="language-asm">main:
        push    rbp
        mov     rbp, rsp
        mov     dword ptr [rbp - 4], 0
        mov     dword ptr [rbp - 8], 32
        xor     eax, eax
        pop     rbp
        ret
</code></pre>
<ol start="7">
<li><strong>Can modify <code>constexpr</code> object that has a lifetime extends longer than the <code>constexpr</code> function</strong>.</li>
</ol>
<pre><code class="language-cpp">constexpr int next(int x)
{
    return ++x;
}

char buffer[next(5)] = { 0 };
</code></pre>
<h2 id="constructor"><a class="header" href="#constructor">Constructor</a></h2>
<p><code>constexpr</code> constructors in C++ are used to create constant expressions of user-defined types during compile-time. They are useful because they allow for more efficient code by performing computations at compile-time and enabling the usage of user-defined types in other <code>constexpr</code> contexts.</p>
<p><code>constexpr</code> constructors were introduced in C++11, along with the general <code>constexpr</code> specifier.</p>
<p>Conditions (or constraints) for <code>constexpr</code> constructors:</p>
<ol>
<li>The constructor must not be a copy or move constructor.</li>
<li>Every expression and construct used in the constructor must be a constant expression.</li>
<li>Every base class and member of the class must have a <code>constexpr</code> constructor.</li>
<li>Every constructor call and full-expression in the constructor's member initializers must be a constant expression.</li>
</ol>
<p>Here's an example of a <code>constexpr</code> constructor:</p>
<pre><code class="language-cpp">class Point {
public:
    constexpr Point(int x, int y) : x_(x), y_(y) {
        // Since C++14, the body of a constexpr constructor can include
        // other constructs like if statements and loops, as long as they
        // meet the constexpr requirements.
        if (x_ &lt; 0) { x_ = 0; }
        if (y_ &lt; 0) { y_ = 0; }
    }

    constexpr int getX() const { return x_; }
    constexpr int getY() const { return y_; }

private:
    int x_;
    int y_;
};

int main() {
    constexpr Point p1(1, 2);
    constexpr int x = p1.getX();
    constexpr int y = p1.getY();
}
</code></pre>
<h3 id="member-initializer"><a class="header" href="#member-initializer"><em>Member initializer</em></a></h3>
<p>When defining a <code>constexpr</code> constructor,  the constructor's member initializer list must only contain constant expressions. This means that when initializing member variables or calling base class constructors, the expressions used must be evaluable compile-time. This is required to <em>guarantee</em> that the object can be constructed as a constant expression during compile-time.</p>
<p>Here's an example to illustrate this requirement:</p>
<pre><code class="language-cpp">class Base {
public:
    constexpr Base(int value) : value_(value) {}

private:
    int value_;
};

class Derived : public Base {
public:
    // Both initializers are constant expressions
    constexpr Derived(int baseValue, int derivedValue) 
        : Base(baseValue), derivedValue_(derivedValue) {} // Both initializers are constant expressions

private:
    int derivedValue_;
};

int main() {
    // Constructed as a constant expression during compile-time
    constexpr Derived d(1, 2); 
}
</code></pre>
<h2 id="destructor"><a class="header" href="#destructor">Destructor</a></h2>
<p>If a class has a <code>constexpr</code> constructor and is meant to be used in a <code>constexpr</code> context, then the destructor should be trivial. A trivial destructor does not perform any custom actions, allowing the object to be safely used in a <code>constexpr</code> context.</p>
<blockquote>
<p>A destructor is considered trivial if:</p>
<ol>
<li>It is not user-provided (i.e., the compiler generates the destructor implicitly).</li>
<li>The class has no virtual functions or virtual base classes.</li>
<li>All direct base classes have trivial destructors.</li>
<li>For all non-static data members of the class that are of class type (or array thereof), each such class has a trivial destructor.</li>
</ol>
</blockquote>
<p>Here's an example of a class with a <code>constexpr</code> constructor and a trivial destructor:</p>
<pre><code class="language-cpp">class Point {
public:
    constexpr Point(int x, int y) : x_(x), y_(y) {}

    // Destructor is trivial (not user-provided and no custom actions)
    // ~Point() = default;

    constexpr int getX() const { return x_; }
    constexpr int getY() const { return y_; }

private:
    int x_;
    int y_;
};

int main() {
    constexpr Point p(1, 2);
}
</code></pre>
<h2 id="constexpr-function-returning-void"><a class="header" href="#constexpr-function-returning-void"><code>constexpr</code> function returning <code>void</code></a></h2>
<p>A member function of a class can be declared <code>constexpr</code> and have a return type of <code>void</code>, for performing a sequence of actions at compile time. For example:</p>
<pre><code class="language-cpp">class MyClass {
public:
    constexpr void doSomething() {
        myData = 42; // Set a constexpr data member
    }

    constexpr int getMyData() const {
        return myData; // Return the value of the constexpr data member
    }

private:
    int myData = 0; // Define a constexpr data member
};

int main() {
    constexpr MyClass obj;
    obj.doSomething(); // This call is evaluated at compile time
    static_assert(obj.getMyData() == 42, "Unexpected value of myData");
}
</code></pre>
<p>Note that <code>constexpr void doSomething()</code> does not have to be qualified with <code>const</code>.</p>
<h2 id="precision-of-floating-point-constexpr"><a class="header" href="#precision-of-floating-point-constexpr">Precision of floating-point <code>constexpr</code></a></h2>
<p>In C++11 and later, <code>constexpr</code> functions can compute floating-point expressions and return floating-point values as constant expressions.</p>
<blockquote>
<p>One limitation of <code>constexpr</code> floating-point computations is that they must terminate in a finite number of steps known at compile time, which means that they cannot compute certain mathematical functions or operations that require an infinite number of steps or iterations. Because of this, the use of functions like <code>std::sin</code> and <code>std::sqrt</code> within <code>constexpr</code> functions is not allowed inside <code>constexpr</code> function.</p>
<p>Additionally, the standard imposes specific requirements on the rounding behavior of constexpr floating point operations. For example, if a constexpr floating point operation results in a value that cannot be represented exactly, the result must be rounded in a manner consistent with the floating point rounding mode specified by the implementation.</p>
</blockquote>
<p>The C++ standard requires that <code>constexpr</code> functions produce the same results as their non-<code>constexpr</code> counterparts when called with the same arguments.</p>
<p>This means that if a non-<code>constexpr</code> function performs a floating point computation with a certain precision, a <code>constexpr</code> function that performs the same computation must produce a result that is at least as precise. The standard does not specify a minimum level of precision, but it requires that the result of a <code>constexpr</code> floating point computation be consistent and reproducible, so that the same result is obtained every time the computation is performed.</p>
<p>In practice, the precision of <code>constexpr</code> floating point computations will depend on the compiler and the platform being used. In general, compilers will try to produce <code>constexpr</code> results that are as precise as possible, but there may be cases where the precision is lower than the runtime counterpart due to limitations of the compiler or platform.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../CompileTimeEvaluation/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../CompileTimeEvaluation/NumericLimit.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../CompileTimeEvaluation/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../CompileTimeEvaluation/NumericLimit.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
